---
title: कुबेरनेट्स में Windows कंटेनर
content_type: concept
weight: 65
---

<!-- overview -->

Windows एप्लिकेशन कई संगठनों में चलने वाली सेवाओं और अनुप्रयोगों के एक बड़े हिस्से का गठन करते हैं। 
[Windows कंटेनर](https://aka.ms/windowscontainers) प्रक्रियाओं और पैकेज निर्भरता को समाहित करने का एक तरीका 
प्रदान करते हैं, जिससे DevOps प्रथाओं का उपयोग करना और Windows अनुप्रयोगों के लिए क्लाउड नेटिव पैटर्न का 
पालन करना आसान हो जाता है। 

Windows-आधारित अनुप्रयोगों और Linux-आधारित अनुप्रयोगों में निवेश वाले संगठनों को अपने कार्यभार को प्रबंधित 
करने के लिए अलग ऑर्केस्ट्रेटर की तलाश करने की आवश्यकता नहीं है, जिससे ऑपरेटिंग सिस्टम की परवाह किए बिना, 
उनके परिनियोजन में परिचालन क्षमता में वृद्धि होती है।

<!-- body -->

## कुबेरनेट्स में Windows नोड्स

कुबेरनेट्स में Windows कंटेनरों के ऑर्केस्ट्रेशन को सक्षम करने के लिए, अपने मौजूदा Linux क्लस्टर में 
Windows नोड्स शामिल करें। कुबेरनेट्स पर {{< glossary_tooltip text="पॉड्स" term_id="pod" >}} में Windows 
कंटेनरों को शेड्यूल करना Linux-आधारित कंटेनरों को शेड्यूल करने के समान है।

Windows कंटेनर चलाने के लिए, आपके कुबेरनेट्स क्लस्टर में कई ऑपरेटिंग सिस्टम शामिल होने चाहिए। 
जबकि आप केवल Linux पर {{< glossary_tooltip text="कंट्रोल प्लेन" term_id="control-plane" >}} चला सकते हैं, 
आप अपने वर्कलोड की जरूरतों के आधार पर Windows या Linux चलाने वाले वर्कर नोड्स को तैनात कर सकते हैं।

Windows {{< glossary_tooltip text="नोड्स" term_id="node" >}} [समर्थित](#windows-os-version-support) हैं 
बशर्ते कि ऑपरेटिंग सिस्टम Windows Server 2019 हो।

यह दस्तावेज़ *Windows कंटेनर* शब्द का उपयोग प्रोसेस आइसोलेशन वाले Windows कंटेनर के लिए करता है। कुबेरनेट्स 
[हाइपर-वी](https://docs.microsoft.com/en-us/virtualization/windowscontainers/manage-containers/hyperv-container)
आइसोलेशन के साथ Windows कंटेनर चलाने का समर्थन नहीं करता है

## संसाधन प्रबंधन

Linux नोड्स पर, {{< glossary_tooltip text="cgroups" term_id="cgroup" >}} को संसाधन नियंत्रण के लिए पॉड सीमा 
के रूप में उपयोग किया जाता है। नेटवर्क, प्रक्रिया और फ़ाइल सिस्टम अलगाव के लिए उस सीमा के भीतर कंटेनर बनाए 
जाते हैं। Linux cgroup APIs का उपयोग CPU, I/O, और मेमोरी उपयोग के आँकड़े एकत्र करने के लिए किया जा सकता है।

इसके विपरीत, Windows एक कंटेनर में सभी प्रक्रियाओं को शामिल करने और होस्ट से तार्किक अलगाव प्रदान करने के 
लिए सिस्टम नेमस्पेस फ़िल्टर के साथ प्रति कंटेनर _जॉब ऑब्जेक्ट_ का उपयोग करता है।
(_जॉब ऑब्जेक्ट्स_ एक Windows प्रक्रिया अलगाव तंत्र हैं और कुबेरनेट्स जिसे {{< glossary_tooltip term_id="जॉब" text="Job" >}} 
कहते हैं, उससे भिन्न हैं)।

नेमस्पेस फ़िल्टरिंग के बिना Windows कंटेनर चलाने का कोई तरीका नहीं है। इसका मतलब यह है कि होस्ट के संदर्भ 
में सिस्टम विशेषाधिकारों का दावा नहीं किया जा सकता है, और इस प्रकार विशेषाधिकार प्राप्त कंटेनर Windows पर 
उपलब्ध नहीं हैं।
कंटेनर होस्ट से एक पहचान ग्रहण नहीं कर सकते क्योंकि सुरक्षा खाता प्रबंधक (एसएएम) अलग है। 

#### मेमोरी रिजर्वेशन {#resource-management-memory}

Windows में आउट-ऑफ-मेमोरी प्रोसेस किलर नहीं है जैसा कि Linux में है। Windows हमेशा सभी उपयोगकर्ता-मोड 
मेमोरी आवंटन को वर्चुअल मानता है, और पेजफाइल अनिवार्य हैं (Linux पर, क्यूबलेट डिफ़ॉल्ट रूप से स्वैप स्पेस 
सक्षम के साथ शुरू नहीं होगा)।

Windows नोड्स कंटेनरों में चल रही प्रक्रियाओं के लिए स्मृति को कम नहीं करते हैं। शुद्ध प्रभाव यह है कि 
Windows मेमोरी की स्थिति को उसी तरह से समाप्त नहीं करेगा जिस तरह से Linux करता है, और मेमोरी से बाहर (ओओएम) 
समाप्ति के अधीन होने के बजाय पेज को डिस्क पर संसाधित करता है। यदि मेमोरी का अधिक प्रावधान किया गया है और 
सभी भौतिक मेमोरी समाप्त हो गई है, तो पेजिंग प्रदर्शन को धीमा कर सकता है।

आप क्यूबलेट पैरामीटर `--kubelet-reserve` और/या `--system-reserve` का उपयोग करके वर्कलोड के लिए मेमोरी उपयोग 
पर सीमाएं लगा सकते हैं; ये नोड (कंटेनरों के बाहर) पर मेमोरी उपयोग के लिए खाते हैं, और [NodeAllocatable](/docs/tasks/administer-cluster/reserve-compute-resources.md#node-allocatable) को कम करते हैं।
जैसे ही आप वर्कलोड परिनियोजित करते हैं, कंटेनरों पर संसाधन सीमाएँ निर्धारित करें। यह `NodeAllocatable` से 
भी घटाता है और शेड्यूलर को नोड भर जाने के बाद अधिक पॉड जोड़ने से रोकता है।

{{< note >}}
जब आप Windows कंटेनर के लिए मेमोरी रिसोर्स लिमिट सेट करते हैं, तो आपको या तो एक लिमिट सेट करनी चाहिए और मेमोरी रिक्वेस्ट को अनिर्दिष्ट छोड़ देना चाहिए, या रिक्वेस्ट को लिमिट के बराबर सेट करना चाहिए।
{{< /note >}}

Windows पर, अति-प्रावधान से बचने के लिए अच्छा अभ्यास यह है कि क्यूबलेट को Windows, कुबेरनेट्स और कंटेनर 
रनटाइम ओवरहेड्स के लिए खाते में कम से कम 2GiB की सिस्टम आरक्षित मेमोरी के साथ कॉन्फ़िगर किया जाए।

#### CPU आरक्षण {#resource-management-cpu}

ऑपरेटिंग सिस्टम, कंटेनर रनटाइम और कुबेरनेट्स होस्ट प्रक्रियाओं जैसे क्यूबलेट द्वारा CPU उपयोग के लिए खाते 
के लिए, आप कुल CPU का एक प्रतिशत आरक्षित कर सकते हैं (और चाहिए भी)। आपको इस CPU आरक्षण को नोड पर उपलब्ध CPU 
कोर की संख्या को ध्यान में रखते हुए निर्धारित करना चाहिए। आरक्षित करने के लिए CPU प्रतिशत पर निर्णय लेने के 
लिए, प्रत्येक नोड के लिए अधिकतम पॉड घनत्व की पहचान करें और वहां चल रही सिस्टम सेवाओं के CPU उपयोग की 
निगरानी करें, फिर एक ऐसा मान चुनें जो आपके कार्यभार की जरूरतों को पूरा करता हो।

आप नोड पर (कंटेनरों के बाहर) CPU उपयोग के लिए क्यूबलेट पैरामीटर `--kubelet-reserve` और/या 
`--system-reserve` का उपयोग करके वर्कलोड के लिए CPU उपयोग पर सीमा लगा सकते हैं।
यह `NodeAllocatable` को कम करता है। पॉड प्लेसमेंट का निर्धारण करते समय क्लस्टर-वाइड शेड्यूलर इस आरक्षण को 
ध्यान में रखता है।

Windows पर, क्यूबलेट, क्यूबलेट प्रक्रिया की प्राथमिकता निर्धारित करने के लिए कमांड-लाइन फ्लैग का समर्थन करता 
है: `--windows-priorityclass`। यह ध्वज क्यूबलेट प्रक्रिया को Windows होस्ट पर चलने वाली अन्य प्रक्रियाओं की 
तुलना में अधिक CPU समय स्लाइस प्राप्त करने की अनुमति देता है। स्वीकार्य मानों और उनके अर्थ के बारे में अधिक 
जानकारी [Windows प्रायोरिटी क्लासेस](https://docs.microsoft.com/en-us/windows/win32/procthread/scheduling-priorities#priority-class) 
पर उपलब्ध है। यह सुनिश्चित करने के लिए कि रनिंग पॉड्स CPU चक्रों के क्यूबलेट को भूखा न रखें, इस फ्लैग को 
`ABOVE_NORMAL_PRIORITY_CLASS` या इससे ऊपर पर सेट करें।

## संगतता और सीमाएं {#limitations}

कुछ नोड सुविधाएँ केवल तभी उपलब्ध होती हैं जब आप एक विशिष्ट [कंटेनर रनटाइम](#container-runtime) का उपयोग 
करते हैं; अन्य Windows नोड्स पर उपलब्ध नहीं हैं, जिनमें शामिल हैं:

* HugePages: Windows कंटेनरों के लिए समर्थित नहीं है
* विशेषाधिकार प्राप्त कंटेनर: Windows कंटेनरों के लिए समर्थित नहीं है
* TerminationGracePeriod: कंटेनरडी की आवश्यकता है

साझा नेमस्पेस की सभी सुविधाएं समर्थित नहीं हैं। अधिक जानकारी के लिए [API संगतता](#api) देखें।

कुबेरनेट्स के खिलाफ परीक्षण किए गए Windows संस्करणों के विवरण के लिए 
[Windows ओएस संस्करण संगतता](#windows-os-version-support) देखें।

API और कुबेक्टल के नजरिए से, Windows कंटेनर Linux-आधारित कंटेनरों की तरह ही व्यवहार करते हैं। हालाँकि, 
प्रमुख कार्यक्षमता में कुछ उल्लेखनीय अंतर हैं जिन्हें इस खंड में उल्लिखित किया गया है।

### Linux के साथ तुलना {#compatibility-linux-similarities}

कुंजी कुबेरनेट्स तत्व Windows में उसी तरह काम करते हैं जैसे वे Linux में करते हैं। 
यह खंड कई प्रमुख वर्कलोड एनबलर्स और वे Windows पर कैसे मैप करते हैं को संदर्भित करता है।

* [पॉड्स](/docs/concepts/workloads/pods/)
  
  पॉड कुबेरनेट्स का मूल निर्माण खंड है - कुबेरनेट्स ऑब्जेक्ट मॉडल में सबसे छोटी और सरल इकाई जिसे आप बनाते 
  हैं या तैनात करते हैं। आप एक ही पॉड में Windows और Linux कंटेनर को तैनात नहीं कर सकते हैं। पॉड में सभी 
  कंटेनर एक ही नोड पर निर्धारित होते हैं जहां प्रत्येक नोड एक विशिष्ट प्लेटफॉर्म और आर्किटेक्चर का 
  प्रतिनिधित्व करता है। निम्नलिखित पॉड क्षमताएं, गुण और घटनाएं Windows कंटेनरों के साथ समर्थित हैं:

  * प्रोसेस आइसोलेशन और वॉल्यूम साझाकरण के साथ प्रति पॉड एकल या एकाधिक कंटेनर
  * पॉड `status` फ़ील्ड
  * तत्परता और जीवंतता जांच
  * पोस्टस्टार्ट और प्रीस्टॉप कंटेनर जीवनचक्र घटनाएँ
  * कॉन्फिग मैप, सीक्रेट्स: एनवायरनमेंट वेरिएबल या वॉल्यूम के रूप में
  * `emptyDir` वॉल्यूम
  * नामित पाइप होस्ट माउंट
  * संसाधन सीमा
* [वर्कलोड संसाधन](/docs/concepts/workloads/controllers/) including:
  * रेप्लिकेसेट 
  * डिप्लॉयमेंट 
  * स्टटेफूलसेट 
  * डेमनसेट
  * जॉब 
  * क्रोंजोब  
  * रेप्लिकेशनकंट्रोलर 
* {{< glossary_tooltip text="सेवाएं" term_id="service" >}}
  अधिक जानकारी के लिए [लोड बैलेंसिंग](#load-balancing-and-services) और सेवाएं देखें।

कुबेरनेट्स पर Windows वर्कलोड को प्रबंधित करने के लिए पॉड्स, वर्कलोड संसाधन और सेवाएं महत्वपूर्ण तत्व हैं। 
हालांकि, अपने दम पर वे एक डायनामिक क्लाउड नेटिव वातावरण में Windows वर्कलोड के उचित जीवनचक्र प्रबंधन को 
सक्षम करने के लिए पर्याप्त नहीं हैं। कुबेरनेट्स इनका भी समर्थन करता है:

* `kubectl exec`
* पॉड और कंटेनर मेट्रिक्स
* {{< glossary_tooltip text="क्षैतिज पॉड ऑटोस्केलिंग" term_id="horizontal-pod-autoscaler" >}}
* {{< glossary_tooltip text="संसाधन कोटा" term_id="resource-quota" >}}
* शेड्यूलर प्रीएंपशन


### Windows नोड्स पर नेटवर्किंग {#compatibility-networking}

Windows कंटेनरों के लिए नेटवर्किंग [CNI प्लगइन्स](/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/) के माध्यम से उजागर होती है।
Windows कंटेनर नेटवर्किंग के संबंध में वर्चुअल मशीनों के समान कार्य करते हैं। प्रत्येक कंटेनर में एक 
वर्चुअल नेटवर्क एडेप्टर (vNIC) होता है जो एक Hyper-V वर्चुअल स्विच (vSwitch) से जुड़ा होता है। होस्ट 
नेटवर्किंग सर्विस (HNS) और होस्ट कंप्यूट सर्विस (HCS) कंटेनर बनाने और कंटेनर vNIC को नेटवर्क से जोड़ने के 
लिए एक साथ काम करते हैं। HCS कंटेनरों के प्रबंधन के लिए जिम्मेदार है जबकि HNS नेटवर्किंग संसाधनों के 
प्रबंधन के लिए जिम्मेदार है जैसे:

* वर्चुअल नेटवर्क (vSwitches के निर्माण सहित)
* समापन बिंदु / vNIC
* नेमस्पेस
* नीतियों में पैकेट एनकैप्सुलेशन, लोड-बैलेंसिंग नियम, ACL और NAT नियम शामिल हैं।

#### कंटेनर नेटवर्किंग {#networking}

Windows HNS और vSwitch नेमस्पेसिंग को लागू करते हैं और पॉड या कंटेनर के लिए आवश्यकतानुसार वर्चुअल NIC बना 
सकते हैं। हालाँकि, कई कॉन्फ़िगरेशन जैसे कि DNS, रूट और मेट्रिक्स Windows रजिस्ट्री डेटाबेस में संग्रहीत 
होते हैं, न कि `/ etc` के अंदर फाइलों के रूप में, जो कि Linux उन कॉन्फ़िगरेशन को कैसे संग्रहीत करता है। 
कंटेनर के लिए Windows रजिस्ट्री होस्ट की रजिस्ट्री से अलग है, इसलिए होस्ट से कंटेनर में `/etc/resolv.conf` 
मैप करने जैसी अवधारणाएं Linux पर समान प्रभाव नहीं डालती हैं। इन्हें उस कंटेनर के संदर्भ में चलाए जा रहे 
Windows API का उपयोग करके कॉन्फ़िगर किया जाना चाहिए। इसलिए CNI कार्यान्वयन को पॉड या कंटेनर में नेटवर्क 
विवरण पास करने के लिए फ़ाइल मैपिंग पर निर्भर रहने के बजाय HNS को कॉल करने की आवश्यकता है।

निम्न नेटवर्किंग कार्यक्षमता Windows नोड्स पर समर्थित नहीं है:

* होस्ट नेटवर्किंग मोड
* नोड से ही स्थानीय नोडपोर्ट एक्सेस (अन्य नोड्स या बाहरी क्लाइंट के लिए काम करता है)
* एक ही सेवा के लिए 64 से अधिक बैकएंड पॉड (या अद्वितीय गंतव्य पते)
* ओवरले नेटवर्क से जुड़े Windows पॉड्स के बीच IPv6 संचार
* Non-DSR मोड में लोकल ट्रैफिक नीति
* Azure-CNI प्लगइन का उपयोग करके या `win-overlay`, `win-bridge` के माध्यम से ICMP प्रोटोकॉल का उपयोग करके आउटबाउंड संचार।\
  विशेष रूप से, Windows डेटा प्लेन ([VFP](https://www.microsoft.com/en-us/research/project/azure-virtual-filtering-platform/)) ICMP पैकेट ट्रांसपोजिशन का समर्थन नहीं करता है, और इसका मतलब है :
   * एक ही नेटवर्क के भीतर गंतव्यों के लिए निर्देशित ICMP पैकेट (जैसे पिंग के माध्यम से पॉड से पॉड संचार) अपेक्षित और बिना किसी सीमा के काम करते हैं;
   * TCP/UDP पैकेट अपेक्षित और बिना किसी सीमा के कार्य करते हैं;
   * एक रिमोट नेटवर्क से गुजरने के लिए निर्देशित ICMP पैकेट (उदाहरण के लिए पिंग के माध्यम से बाहरी इंटरनेट संचार के लिए पॉड) को स्थानांतरित नहीं किया जा सकता है और इस प्रकार उनके स्रोत पर वापस नहीं भेजा जाएगा;
   * चूंकि TCP/UDP पैकेट अभी भी स्थानांतरित किए जा सकते हैं, आप बाहरी दुनिया के साथ कनेक्टिविटी में कुछ डिबगिंग अंतर्दृष्टि प्राप्त करने के लिए `ping <destination>` को `curl <destination>` से प्रतिस्थापित कर सकते हैं। 

क्यूब-प्रॉक्सी में ओवरले नेटवर्किंग सपोर्ट एक बीटा फीचर है। इसके अलावा, इसे 
[KB4482887](https://support.microsoft.com/en-us/help/4482887/windows-10-update-kb4482887) को Windows Server 2019 पर इंस्टॉल करना होगा।

#### नेटवर्क मोड

Windows पांच अलग-अलग नेटवर्किंग ड्राइवर/मोड का समर्थन करता है: l2bridge, L2tunnel, ओवरले (बीटा), 
ट्रांसपेरेंट और NAT. Windows और Linux वर्कर नोड्स के साथ एक विषम क्लस्टर में, आपको एक नेटवर्किंग समाधान का 
चयन करने की आवश्यकता है जो Windows और Linux दोनों पर संगत हो। निम्नलिखित आउट-ऑफ-ट्री प्लगइन्स Windows पर 
समर्थित हैं, प्रत्येक सीएनआई का उपयोग कब करना है, इस पर सिफारिशों के साथ:

| नेटवर्क ड्राइवर | विवरण | कंटेनर पैकेट संशोधन | नेटवर्क प्लगइन्स | नेटवर्क प्लगइन अभिलक्षण |
| --------- | ---- | -------------- | ---------- | ---------------- |
| l2bridge | कंटेनर बाहरी vSwitch से जुड़े होते हैं। कंटेनर अंडरले नेटवर्क से जुड़े होते हैं, हालांकि भौतिक नेटवर्क को कंटेनर MAC सीखने की आवश्यकता नहीं होती है क्योंकि वे प्रवेश/निकास पर फिर से लिखे जाते हैं। | MAC को होस्ट करने के लिए MAC को फिर से लिखा जाता है, HNS OutboundNAT नीति का उपयोग करके IP को होस्ट करने के लिए IP को फिर से लिखा जा सकता है। | [win-bridge](https://github.com/containernetworking/plugins/tree/master/plugins/main/windows/win-bridge), [Azure-CNI](https://github.com/Azure/azure-container-networking/blob/master/docs/cni.md), फलालैन होस्ट-गेटवे win-bridge का उपयोग करता है | win-bridge l2bridge नेटवर्क मोड का उपयोग करता है, कंटेनरों को मेजबानों के बुनियाद से जोड़ता है, सर्वश्रेष्ठ प्रदर्शन की पेशकश करता है। इंटर-नोड कनेक्टिविटी के लिए यूजर-डिफ़ाइंड रूट्स (UDR) की आवश्यकता होती है। |
| L2Tunnel | यह l2bridge का एक विशेष मामला है, लेकिन केवल Azure पर उपयोग किया जाता है। सभी पैकेट वर्चुअलाइजेशन होस्ट को भेजे जाते हैं जहां एसडीएन नीति लागू होती है। | मैक फिर से लिखा, अंडरले नेटवर्क पर दिखाई देने वाला आईपी | [Azure-CNI](https://github.com/Azure/azure-container-networking/blob/master/docs/cni.md) | Azure-CNI, Azure vNET के साथ कंटेनरों के एकीकरण की अनुमति देता है, और उन्हें क्षमताओं के सेट का लाभ उठाने की अनुमति देता है जो [Azure वर्चुअल नेटवर्क प्रदान करता है](https://azure.microsoft.com/en-us/services/virtual-network/)। उदाहरण के लिए, Azure सेवाओं से सुरक्षित रूप से कनेक्ट करें या Azure NSG का उपयोग करें। [कुछ उदाहरणों के लिए Azure-cni] देखें (https://docs.microsoft.com/en-us/azure/aks/concepts-network#azure-cni-advanced-networking) | 
| ओवरले (कुबेरनेट्स में Windows के लिए ओवरले नेटवर्किंग *अल्फा* चरण में है) | कंटेनरों को एक बाहरी vSwitch से जुड़ा एक vNIC दिया जाता है। प्रत्येक ओवरले नेटवर्क को अपना स्वयं का IP सबनेट मिलता है, जिसे एक कस्टम IP प्रीफिक्स द्वारा परिभाषित किया जाता है। ओवरले नेटवर्क ड्राइवर VXLAN एनकैप्सुलेशन का उपयोग करता है। | बाहरी हैडर के द्वारा एन्काप्सुलेट किया गया। | [win-overlay](https://github.com/containernetworking/plugins/tree/master/plugins/main/windows/win-overlay), फलालैन VXLAN (win-overlay का उपयोग करता है) | win-overlay का उपयोग तब किया जाना चाहिए जब वर्चुअल कंटेनर नेटवर्क को मेजबानों के बुनियाद (जैसे सुरक्षा कारणों से) से अलग किया जाना चाहिए। यदि आप अपने डेटासेंटर में IP पर प्रतिबंधित हैं तो IP को विभिन्न ओवरले नेटवर्क (जिसमें अलग-अलग VNID टैग हैं) के लिए पुन: उपयोग करने की अनुमति देता है। इस विकल्प के लिए Windows सर्वर 2019 पर [KB4489899](https://support.microsoft.com/help/4489899) की आवश्यकता है।
| पारदर्शी ([ovn-कुबेरनेट्स](https://github.com/openvswitch/ovn-kubernetes) के लिए विशेष उपयोग के मामले) |एक बाहरी vSwitch की आवश्यकता है। कंटेनर एक बाहरी vSwitch से जुड़े होते हैं जो तार्किक नेटवर्क (लॉजिकल स्विच और राउटर) के माध्यम से इंट्रा-पॉड संचार को सक्षम बनाता है। | पैकेट को या तो  [GENEVE](https://datatracker.ietf.org/doc/draft-gross-geneve/) या [STT](https://datatracker.ietf.org/doc/draft-davie-stt/) टनलिंग के माध्यम से पॉड्स तक पहुँचने के लिए इनकैप्सुलेट किया जाता है जो एक ही होस्ट पर नहीं होते हैं। <br/> पैकेट को ovn नेटवर्क नियंत्रक द्वारा आपूर्ति की गई टनल मेटाडेटा जानकारी के माध्यम से अग्रेषित या गिराया जाता है। <br/> NAT उत्तर-दक्षिण संचार के लिए किया जाता है। | [ovn-kubernetes](https://github.com/openvswitch/ovn-kubernetes) | [ansible के माध्यम से परिनियोजित करें](https://github.com/openvswitch/ovn-kubernetes/tree/master/contrib)। वितरित ACL को Kubernetes नीतियों के माध्यम से लागू किया जा सकता है। IPAM समर्थन। क्यूब-प्रॉक्सी के बिना लोड-बैलेंसिंग हासिल की जा सकती है। नेटिंग iptables/netsh का उपयोग किए बिना किया जाता है। |
| NAT (*कुबेरनेट्स में उपयोग नहीं किया गया*) | कंटेनरों को एक आंतरिक vSwitch से जुड़ा एक vNIC दिया जाता है। DNS/DHCP [WinNAT](https://blogs.technet.microsoft.com/virtualization/2016/05/25/windows-nat-winnat-capabilities-and-limitations/) नामक एक आंतरिक घटक का उपयोग करके प्रदान किया जाता है  | MAC/IP को होस्ट करने के लिए MAC और IP को फिर से लिखा जाता है। | [nat](https://github.com/Microsoft/windows-container-networking/tree/master/plugins/nat) | पूर्णता के लिए यहां शामिल है |

जैसा कि ऊपर बताया गया है, [फलालैन](https://github.com/coreos/flannel) CNI [मेटा प्लगइन](https://github.com/containernetworking/plugins/tree/master/plugins/meta/flannel) Windows पर [VXLAN नेटवर्क बैकएंड](https://github.com/coreos/flannel/blob/master/Documentation/backends.md#vxlan) (**alpha support** ; delegates to win-overlay) (**अल्फा सपोर्ट**; win-overlay के प्रतिनिधि) और [होस्ट-गेटवे नेटवर्क बैकएंड](https://github.com/coreos/flannel/blob/master/Documentation/backends.md#host-gw) (stable support; delegates to win-bridge) (स्थिर समर्थन; win-bridge के प्रतिनिधि) के माध्यम से भी [समर्थित](https://github.com/containernetworking/plugins/tree/master/plugins/meta/flannel#windows-support-experimental) है। 

यह प्लगइन एक संदर्भ CNI प्लगइन्स (win-overlay, win-bridge) को सौंपने का समर्थन करता है, स्वचालित नोड सबनेट 
लीज असाइनमेंट और HNS नेटवर्क निर्माण के लिए Windows (FlannelD) पर फलालैन डेमॉन के संयोजन के साथ काम करने के 
लिए। यह प्लगइन अपनी स्वयं की कॉन्फ़िगरेशन फ़ाइल (cni.conf) में पढ़ता है, और इसे FlannelD द्वारा उत्पन्न 
subnet.env फ़ाइल से पर्यावरण चर के साथ जोड़ता है। यह तब नेटवर्क प्लंबिंग के लिए संदर्भ CNI प्लगइन्स में से 
एक को सौंपता है, और IPAM प्लगइन (उदाहरण के लिए: `host-local`) को नोड-असाइन सबनेट युक्त सही कॉन्फ़िगरेशन 
भेजता है।

नोड, पॉड और सर्विस ऑब्जेक्ट के लिए, निम्न नेटवर्क प्रवाह TCP/UDP ट्रैफ़िक के लिए समर्थित हैं:

* पॉड → पॉड (IP)
* पॉड → पॉड (नाम)
* पॉड → सर्विस (क्लस्टर IP)
* पॉड → सर्विस (पीक्यूडीएन, लेकिन केवल अगर "." नहीं हैं)
* पॉड → सर्विस (FQDN)
* पॉड → बाहरी (IP)
* पॉड → बाहरी (DNS)
* नोड → पॉड
* पॉड → नोड

#### सीएनआई प्लगइन सीमाएं

* Windows संदर्भ नेटवर्क प्लगइन्स win-bridge और win-overlay [CNI स्पेक] (https://github.com/containernetworking/cni/blob/master/SPEC.md) v0.4.0 को लागू नहीं करते हैं, एक लापता `CHECK` कार्यान्वयन के कारण।
* फलालैन VXLAN CNI प्लगइन की Windows पर निम्नलिखित सीमाएँ हैं:

1. डिजाइन द्वारा नोड-पॉड कनेक्टिविटी संभव नहीं है। यह केवल Flannel v0.12.0 (या उच्चतर) वाले स्थानीय पॉड्स के लिए संभव है।
2. फलालैन VNI 4096 और UDP पोर्ट 4789 का उपयोग करने के लिए प्रतिबंधित है। इन मापदंडों पर अधिक विवरण के लिए   आधिकारिक [फलालैन VXLAN](https://github.com/coreos/flannel/blob/master/Documentation/backends.md#vxlan) बैकएंड डॉक्स देखें।

#### IP एड्रेस मैनेजमेंट (IPAM) {#ipam}

निम्न IPAM विकल्प Windows पर समर्थित हैं:

* [host-local](https://github.com/containernetworking/plugins/tree/master/plugins/ipam/host-local)
* HNS IPAM (इनबॉक्स प्लेटफॉर्म IPAM, यह एक फॉलबैक है जब कोई IPAM सेट नहीं होता है)
* [azure-vnet-ipam](https://github.com/Azure/azure-container-networking/blob/master/docs/ipam.md) (केवल Azure-CNI के लिए)

#### लोड संतुलन और सेवाएं

कुबेरनेट्स {{< glossary_tooltip text="सेवा" term_id="service" >}} एक अमूर्त है जो पॉड्स के लॉजिकल सेट और 
नेटवर्क पर उन्हें एक्सेस करने के साधन को परिभाषित करती है।
एक क्लस्टर में जिसमें Windows नोड्स शामिल हैं, आप निम्न प्रकार की सेवा का उपयोग कर सकते हैं:

  * `NodePort`
  * `ClusterIP`
  * `LoadBalancer`
  * `ExternalName`

Windows कंटेनर नेटवर्किंग कुछ महत्वपूर्ण तरीकों से Linux नेटवर्किंग से अलग है।
[Windows कंटेनर नेटवर्किंग के लिए Microsoft दस्तावेज़](https://docs.microsoft.com/en-us/virtualization/windowscontainers/container-networking/architecture) 
अतिरिक्त विवरण और पृष्ठभूमि प्रदान करता है।

Windows पर, आप सेवाओं को कॉन्फ़िगर करने और संतुलन व्यवहार लोड करने के लिए निम्न सेटिंग्स का उपयोग कर सकते हैं:

{{< table caption="Windows सेवा सेटिंग्स" >}}
| फ़ीचर | विवरण | समर्थित कुबेरनेट्स संस्करण | समर्थित Windows ओएस बिल्ड | कैसे सक्षम करें |
| --- | ---- | ------------------ | --------------------- | ---------- |
| सत्र आत्मीयता | यह सुनिश्चित करता है कि किसी विशेष क्लाइंट से कनेक्शन हर बार उसी पॉड को पास किया जाता है। | v1.20+ | [Windows सर्वर वीनेक्स्ट इनसाइडर प्रीव्यू बिल्ड 19551](https://blogs.windows.com/windowsexperience/2020/01/28/announcing-windows-server-vnext-insider-preview-build-19551/) (या उच्चतर) | `service.spec.sessionAffinity` को "ClientIP" पर सेट करें |
| डायरेक्ट सर्वर रिटर्न (DSR) | लोड संतुलन मोड जहां IP एड्रेस ठीक हो जाता है और LBNAT सीधे कंटेनर vSwitch पोर्ट पर होता है; सेवा यातायात स्रोत आईपी के साथ आता है जो मूल पॉड आईपी के रूप में सेट होता है। | v1.20+ | Windows सर्वर 2019 | क्यूब-प्रॉक्सी में निम्न फ़्लैग सेट करें: `--feature-gates="WinDSR=true" --enable-dsr=true` |
| संरक्षित-गंतव्य | सेवा ट्रैफ़िक के DNAT को छोड़ देता है, जिससे लक्ष्य सेवा के वर्चुअल IP को बैकएंड पॉड तक पहुँचने वाले पैकेट में संरक्षित किया जाता है। नोड-नोड अग्रेषण को भी अक्षम करता है। | v1.20+ | Windows सर्वर, संस्करण 1903 (या उच्चतर) | सेवा एनोटेशन में `"preserve-destination": "true"` सेट करें और क्यूब-प्रॉक्सी में DSR सक्षम करें। |
| IPv4/IPv6 डुअल-स्टैक नेटवर्किंग | नेटिव IPv4-to-IPv4 IPv6-to-IPv6 संचार के साथ समानांतर में एक क्लस्टर से, से, और भीतर | v1.19+ | Windows सर्वर, संस्करण 2019 | देखें [IPv4/IPv6 डुअल-स्टैक](#ipv4ipv6-dual-stack) |
| क्लाइंट आईपी संरक्षण | सुनिश्चित करता है कि आने वाले प्रवेश यातायात का स्रोत आईपी संरक्षित हो जाता है। नोड-नोड अग्रेषण को भी अक्षम करता है। | v1.20+ | Windows सर्वर, संस्करण 2019 | `service.spec.externalTrafficPolicy` को "Local" पर सेट करें और क्यूब-प्रॉक्सी में DSR सक्षम करें |
{{< /table >}}

##### सत्र आत्मीयता

`service.spec.sessionAffinityConfig.clientIP.timeoutSeconds` का उपयोग करके Windows सेवाओं के लिए अधिकतम 
सत्र स्टिकी समय सेट करना समर्थित नहीं है।

#### DNS {#dns-limitations}

* ClusterFirstWithHostNet DNS के लिए समर्थित नहीं है। Windows उन सभी नामों को एक FQDN के रूप में मानता है जो `.` के साथ हैं और FQDN रिज़ॉल्यूशन को छोड़ देते हैं।
* Linux पर, आपके पास DNS प्रत्यय सूची है, जिसका उपयोग PQDN को हल करने का प्रयास करते समय किया जाता है। Windows पर, आपके पास केवल 1 DNS प्रत्यय हो सकता है, जो कि उस पॉड के नामस्थान से जुड़ा DNS प्रत्यय है (उदाहरण के लिए mydns.svc.cluster.local)। Windows FQDNs और सेवाओं या नामों को केवल उस प्रत्यय के साथ हल कर सकता है। उदाहरण के लिए, डिफ़ॉल्ट नाम स्थान में उत्पन्न पॉड में DNS प्रत्यय होगा **default.svc.cluster.local**। Windows पॉड के अंदर, आप **kubernetes.default.svc.cluster.local** और **kubernetes** दोनों को हल कर सकते हैं, लेकिन इनके बीच के नहीं, जैसे **kubernetes.default** या **kubernetes.default.svc**।
* Windows पर, कई DNS रिज़ॉल्वर हैं जिनका उपयोग किया जा सकता है। चूंकि ये थोड़े अलग व्यवहार के साथ आते हैं, नाम क्वेरी समाधान के लिए `Resolve-DNSName` उपयोगिता का उपयोग करने की अनुशंसा की जाती है।

#### IPv6 नेटवर्किंग

Windows पर Kubernetes सिंगल-स्टैक "IPv6-only" नेटवर्किंग का समर्थन नहीं करता है। हालांकि, एकल परिवार सेवाओं 
के साथ पॉड्स और नोड्स के लिए डुअल-स्टैक IPv4/IPv6 नेटवर्किंग समर्थित है।

आप `IPv6DualStack` [फीचर गेट] (/ डॉक्स/रेफरेंस/कमांड-लाइन-टूल्स-रेफरेंस/फीचर-गेट्स/) का उपयोग करके 
`l2bridge` नेटवर्क के लिए IPv4/IPv6 डुअल-स्टैक नेटवर्किंग को सक्षम कर सकते हैं।
अधिक जानकारी के लिए देखें [इनेबल IPv4/IPv6 डुअल स्टैक](/docs/concepts/services-networking/dual-stack#enable-ipv4ipv6-dual-stack)।

{{< note >}}
Windows पर ओवरले (VXLAN) नेटवर्क डुअल-स्टैक नेटवर्किंग का समर्थन नहीं करते हैं।
{{< /note >}}

### परसिस्टेंट स्टोरेज {#compatibility-storage}

कंटेनर परतों को माउंट करने और NTFS पर आधारित एक कॉपी फाइल सिस्टम बनाने के लिए Windows में एक स्तरित फाइल 
सिस्टम ड्राइवर है। कंटेनर में सभी फ़ाइल पथ केवल उस कंटेनर के संदर्भ में हल किए जाते हैं।

* डॉकर के साथ, वॉल्यूम माउंट केवल कंटेनर में एक निर्देशिका को लक्षित कर सकता है, न कि एक व्यक्तिगत फ़ाइल। यह सीमा CRI-containerD रनटाइम के साथ मौजूद नहीं है।
* वॉल्यूम माउंट फ़ाइलों या निर्देशिकाओं को होस्ट फ़ाइल सिस्टम पर वापस प्रोजेक्ट नहीं कर सकता है।
* रीड-ओन्ली के लिए फाइल सिस्टम समर्थित नहीं हैं क्योंकि Windows रजिस्ट्री और SAM डेटाबेस के लिए हमेशा लेखन पहुंच की आवश्यकता होती है। हालाँकि, रीड-ओन्ली के लिए वॉल्यूम समर्थित हैं।
* वॉल्यूम उपयोगकर्ता-मास्क और अनुमतियां उपलब्ध नहीं हैं। क्योंकि SAM को होस्ट और कंटेनर के बीच साझा नहीं किया जाता है, इसलिए उनके बीच कोई मैपिंग नहीं होती है। कंटेनर के संदर्भ में सभी अनुमतियों का समाधान किया जाता है।

परिणामस्वरूप, निम्न संग्रहण कार्यक्षमता Windows नोड्स पर समर्थित नहीं है:

* वॉल्यूम सबपाथ माउंट: केवल संपूर्ण वॉल्यूम को Windows कंटेनर में रखा जा सकता है
* सीक्रेट्स के लिए सबपाथ वॉल्यूम मॉउंटिंग
* होस्ट माउंट प्रोजेक्शन
* रीड-ओन्ली के लिए रूट फाइल सिस्टम (मैप किए गए वॉल्यूम अभी भी `readOnly` का समर्थन करते हैं)
* ब्लॉक डिवाइस मैपिंग
* मेमोरी स्टोरेज माध्यम के रूप में (उदाहरण के लिए, `emptyDir.medium` `Memory` पर सेट है)
* फ़ाइल सिस्टम सुविधाएँ जैसे uid/gid; प्रति-उपयोगकर्ता Linux फ़ाइल सिस्टम अनुमतियाँ
* DefaultMode (UID/GID निर्भरता के कारण)
* NFS आधारित स्टोरेज/वॉल्यूम समर्थन
* माउंटेड वॉल्यूम का विस्तार करना (resizefs)

कुबेरनेट्स {{< glossary_tooltip text="वॉल्यूम" term_id="volume" >}} जटिल अनुप्रयोगों को सक्षम करता है, डेटा 
पर्सिस्टेंस और पॉड वॉल्यूम साझाकरण आवश्यकताओं के साथ, कुबेरनेट्स पर तैनात किया जा सकता है। एक विशिष्ट 
स्टोरेज बैक-एंड या प्रोटोकॉल से जुड़े लगातार वॉल्यूम के प्रबंधन में वॉल्यूम का प्रावधान/डी-प्रावधान/
आकार बदलना, कुबेरनेट्स नोड से वॉल्यूम को जोड़ना/अलग करना और वॉल्यूम को अलग-अलग कंटेनरों में/से माउंट 
करना/हटाना जैसी क्रियाएं शामिल हैं। एक पॉड में जिसे डेटा बनाए रखने की आवश्यकता होती है।

एक विशिष्ट स्टोरेज बैक-एंड या प्रोटोकॉल के लिए इन वॉल्यूम प्रबंधन क्रियाओं को लागू करने वाला कोड कुबेरनेट्स 
वॉल्यूम [प्लगइन] (/ डॉक्स/कॉन्सेप्ट्स/स्टोरेज/वॉल्यूम/# टाइप्स-ऑफ-वॉल्यूम) के रूप में शिप किया जाता है।
कुबेरनेट्स वॉल्यूम प्लगइन्स के निम्नलिखित व्यापक वर्ग Windows पर समर्थित हैं: 

##### इन-ट्री वॉल्यूम प्लगइन्स

कोर कुबेरनेट्स कॉड बेस के हिस्से के रूप में इन-ट्री वॉल्यूम प्लगइन्स से जुड़ा कोड। इन-ट्री वॉल्यूम प्लग इन 
के परिनियोजन के लिए अतिरिक्त स्क्रिप्ट की स्थापना या अलग कंटेनरीकृत प्लगइन घटकों की तैनाती की आवश्यकता नहीं 
होती है। ये प्लगइन्स स्टोरेज बैकएंड में वॉल्यूम के प्रोविजनिंग/डी-प्रोविजनिंग और आकार का आकार बदल सकते 
हैं, एक कुबेरनेट्स नोड से/वॉल्यूम को अटैच/डिटैच कर सकते हैं और एक पॉड में अलग-अलग कंटेनरों से वॉल्यूम 
को माउंट/डिसमाउंट कर सकते हैं। निम्नलिखित इन-ट्री प्लगइन्स Windows नोड्स पर लगातार स्टोरेज का समर्थन करते हैं:

* [`awsElasticBlockStore`](/docs/concepts/storage/volumes/#awselasticblockstore)
* [`azureDisk`](/docs/concepts/storage/volumes/#azuredisk)
* [`azureFile`](/docs/concepts/storage/volumes/#azurefile)
* [`gcePersistentDisk`](/docs/concepts/storage/volumes/#gcepersistentdisk)
* [`vsphereVolume`](/docs/concepts/storage/volumes/#vspherevolume)

#### फ्लेक्सवॉल्यूम प्लगइन्स

[FlexVolume](/docs/concepts/storage/volumes/#flexVolume) प्लगइन्स से जुड़े कोड आउट-ऑफ-ट्री स्क्रिप्ट या 
बायनेरिज़ के रूप में शिप होते हैं जिन्हें सीधे होस्ट पर तैनात करने की आवश्यकता होती है। फ्लेक्सवॉल्यूम 
प्लगइन्स कुबेरनेट्स नोड से/वॉल्यूम को जोड़ने/डिटैच करने और एक पॉड में अलग-अलग कंटेनर से वॉल्यूम को माउंट/डिसमाउंट करने का काम करता है। FlexVolume प्लगइन्स से जुड़े लगातार वॉल्यूम का प्रोविजनिंग/डी-प्रोविजनिंग 
एक बाहरी प्रोविजनर के माध्यम से किया जा सकता है जो आमतौर पर FlexVolume प्लगइन्स से अलग होता है। निम्न 
FlexVolume [प्लगइन्स](https://github.com/Microsoft/K8s-Storage-Plugins/tree/master/flexvolume/windows), 
होस्ट पर PowerShell स्क्रिप्ट के रूप में परिनियोजित, Windows नोड्स का समर्थन करते हैं:

* [SMB](https://github.com/microsoft/K8s-Storage-Plugins/tree/master/flexvolume/windows/plugins/microsoft.com~smb.cmd)
* [iSCSI](https://github.com/microsoft/K8s-Storage-Plugins/tree/master/flexvolume/windows/plugins/microsoft.com~iscsi.cmd)

#### CSI प्लगइन्स

{{< feature-state for_k8s_version="v1.19" state="beta" >}}

{{<glossary_tooltip text="CSI" term_id="csi" >}} प्लगइन्स से जुड़ा कोड आउट-ऑफ-ट्री स्क्रिप्ट और बायनेरिज़ 
के रूप में शिप होता है जो आमतौर पर कंटेनर इमेज के रूप में वितरित किए जाते हैं और डेमनसेट्स और स्टेटफुलसेट्स 
जैसे मानक कुबेरनेट्स कंस्ट्रक्शन का उपयोग करके तैनात किए जाते हैं। CSI प्लगइन्स कुबेरनेट्स में वॉल्यूम 
प्रबंधन क्रियाओं की एक विस्तृत श्रृंखला को संभालते हैं: वॉल्यूम का प्रावधान/डी-प्रोविज़निंग/आकार बदलना, 
वॉल्यूम को कुबेरनेट्स नोड से/से जोड़ना/अलग करना और एक पॉड में अलग-अलग कंटेनरों में/से वॉल्यूम को 
बढ़ाना/हटाना, बैकअप/स्नैपशॉट और क्लोनिंग का उपयोग करके लगातार डेटा की पुनर्स्थापना। CSI प्लगइन्स में 
आमतौर पर नोड प्लग इन (जो प्रत्येक नोड पर डेमनसेट के रूप में चलता है) और कंट्रोलर प्लगइन्स होते हैं।

CSI नोड प्लगइन्स (विशेष रूप से ब्लॉक डिवाइस या साझा फाइल-सिस्टम के रूप में उजागर होने वाले लगातार वॉल्यूम 
से जुड़े) को डिस्क डिवाइस की स्कैनिंग, फाइल सिस्टम की माउंटिंग आदि जैसे विभिन्न विशेषाधिकार प्राप्त संचालन 
करने की आवश्यकता होती है। ये ऑपरेशन प्रत्येक होस्ट ऑपरेटिंग सिस्टम के लिए भिन्न होते हैं। Linux वर्कर 
नोड्स के लिए, कंटेनरीकृत CSI नोड प्लग इन को आमतौर पर विशेषाधिकार प्राप्त कंटेनरों के रूप में तैनात किया 
जाता है। Windows वर्कर नोड्स के लिए, कंटेनरीकृत CSI नोड प्लगइन्स के लिए विशेषाधिकार प्राप्त संचालन 
[CSI-प्रॉक्सी](https://github.com/kubernetes-csi/csi-proxy) का उपयोग करके समर्थित है, जो की एक 
समुदाय-प्रबंधित, स्टैंड-अलोन बाइनरी जिसे प्रत्येक Windows नोड पर पूर्व-स्थापित करने की आवश्यकता होती है।

अधिक विवरण के लिए, आप जिस CSI प्लगइन को परिनियोजित करना चाहते हैं उसकी परिनियोजन मार्गदर्शिका देखें।

### क्यूबलेट के लिए कमांड लाइन विकल्प {#kubelet-compatibility}

कुछ क्यूबलेट कमांड लाइन विकल्पों का व्यवहार Windows पर अलग तरह से व्यवहार करता है, जैसा कि नीचे वर्णित है:

* `--windows-priorityclass` आपको क्यूबलेट प्रक्रिया की शेड्यूलिंग प्राथमिकता निर्धारित करने देता है (देखें [CPU संसाधन प्रबंधन](#resource-management-cpu))
* `--kubelet-reserve`, `--system-reserve` , और `--eviction-hard` फ्लैग अपडेट [NodeAllocatable](/docs/tasks/admin-cluster/reserve-comput-resource/#node-allocatable)
* '--enforce-node-allocable' का उपयोग करके निष्कासन लागू नहीं किया गया है
* बेदखली के लिए `--eviction-hard` और `--एविक्शन-सॉफ्ट` का प्रयोग नहीं किया जाता है
* Windows नोड पर चलने वाले क्यूबलेट में मेमोरी प्रतिबंध नहीं होते हैं। `--kubelet-reserve` और `--system-reserve` क्यूबलेट या होस्ट पर चलने वाली प्रक्रियाओं पर सीमा निर्धारित नहीं करते हैं। इसका मतलब है कि क्यूबलेट या होस्ट पर एक प्रक्रिया नोड-आवंटन योग्य और अनुसूचक के बाहर स्मृति संसाधन भुखमरी का कारण बन सकती है।
* `MemoryPressure` शर्त लागू नहीं की गई है
* क्यूबलेट OOM निष्कासन कार्रवाई नहीं करता

### API की अनुकूलता {#api}

अधिकांश कुबेरनेट्स API Windows के लिए कैसे काम करते हैं, इसमें कोई अंतर नहीं है। OS और कंटेनर रनटाइम में अंतर के कारण अलग-अलग सूक्ष्मताएं आती हैं रनटाइम। कुछ स्थितियों में कार्यभार संसाधनों पर कुछ गुण डिज़ाइन किए गए थे इस धारणा के तहत कि उन्हें लिनक्स पर लागू किया जाएगा, और Windows पर चलने में विफल रहेगा।

उच्च स्तर पर, ये OS भिन्न अवधारणाएँ हैं:
* पहचान - लिनक्स यूजरआईडी (UID) और ग्रुपआईडी (GID) का उपयोग करता है जो पूर्णांक प्रकारों के रूप में दर्शाए जाते हैं। उपयोगकर्ता और समूह के नाम विहित नहीं हैं - वे `/etc/groups` . में सिर्फ एक उपनाम हैं या `/etc/passwd` यूआईडी जीआईडी पर वापस जाएं। Windows एक बड़े बाइनरी का उपयोग करता है [सुरक्षा पहचानकर्ता](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/security-identifiers) (SID) जो Windows सिक्योरिटी एक्सेस मैनेजर (SAM) डेटाबेस में स्टोर होता है। इस डेटाबेस को मेज़बान के बीच साझा नहीं किया जाता है।
* फ़ाइल अनुमतियां - Windows (SIDs) के आधार पर एक्सेस कंट्रोल सूची का उपयोग करता है, जबकि POSIX सिस्टम जैसे Linux ऑब्जेक्ट अनुमतियों,  _optional_ अभिगम नियंत्रण सूचिय और UID+GID के आधार पर बिटमास्क का उपयोग करता है।
* फ़ाइल पथ - सम्मेलन के आधार पर Windows पर `/` के बजाय `\` का उपयोग करना होता है। गो I पुस्तकालय आमतौर पर दोनों को स्वीकार करते हैं और बस इसे काम करते हैं, लेकिन जब आप पथ या कमांड लाइन जो एक कंटेनर के अंदर व्याख्या की गई है, `\` की आवश्यकता हो सकती है। 
* सिग्नल - Windows इंटरएक्टिव ऐप टर्मिनेशन को अलग तरह से हैंडल करते हैं, और इनमें से एक या अधिक को लागू कर सकते हैं:
    * UI थ्रेड `WM_CLOSE` सहित अच्छी तरह से परिभाषित संदेशों को संभालता है।
    * कंसोल ऐप्स कंट्रोल हैंडलर का उपयोग करके Ctrl-C या Ctrl-break को हैंडल करते हैं।
    * सेवाएँ एक सर्विस कण्ट्रोल हैंडलर हैंडलर फ़ंक्शन पंजीकृत करती हैं जो स्वीकार कर सकता है`SERVICE_CONTROL_STOP` नियंत्रण कोड।

कंटेनर निकास कोड उसी परंपरा का पालन करते हैं जहां 0 सफलता है, और गैर-शून्य विफलता है। विशिष्ट त्रुटि कोड Windows और लिनक्स में भिन्न हो सकते हैं। हालाँकि, निकास कोड कुबेरनेट्स घटकों (क्यूबलेट, क्यूब-प्रॉक्सी) से पारित अपरिवर्तित हैं।

#### कंटेनर विनिर्देशों के लिए फ़ील्ड संगतता {#compatibility-v1-pod-spec-containers}

निम्नलिखित सूची में Windows और लिनक्स के बीच पॉड कंटेनर विनिर्देशों का अंतर बताया गया है:

* Windows कंटेनर रनटाइम में HugePages लागू नहीं होते हैं, और उपलब्ध नहीं होते हैं। उन्हें [एक उपयोगकर्ता विशेषाधिकार](https://docs.microsoft.com/en-us/windows/desktop/Memory/large-page-support) की आवश्यकता होती है जो कंटेनरों के लिए कॉन्फ़िगर करने योग्य नहीं है।
* `requests.cpu` और `requests.memory` - से अनुरोध घटाए जाते हैं नोड उपलब्ध संसाधनों से, इसलिए उनका उपयोग अधिक प्रावधान से बचने के लिए किया जा सकता है। हालाँकि, उनका उपयोग एक अत्यधिक प्रावधान नोड में संसाधनों की गारंटी के लिए नहीं किया जा सकता है।  उन्हें सभी कंटेनरों पर सर्वोत्तम अभ्यास के रूप में लागू किया जाना चाहिए यदि ऑपरेटर पूरी तरह से अधिक प्रावधान से बचना चाहता है।
* `securityContext.allowPrivilegeEscalation` -Windows पर संभव नहीं है; क्षमताओं में से कोई भी जुड़ा हुआ नहीं है
* `securityContext.capabilities` -Windows पर पॉज़िक्स क्षमताओं को लागू नहीं किया गया है
* `securityContext.privileged`-Windows विशेषाधिकार प्राप्त कंटेनरों का समर्थन नहीं करता
* `securityContext.procMount` -Windows में `/ proc` फाइल सिस्टम नहीं है
* `securityContext.readOnlyRootFilesystem` -Windows पर संभव नहीं है; रजिस्ट्री के लिए लेखन पहुंच आवश्यक है
* `securityContext.runAsGroup` -Windows पर संभव नहीं है क्योंकि कोई GID समर्थन नहीं है
* `securityContext.runAsNonRoot` - यह सेटिंग कंटेनर को कंटेनरएडमिनिस्ट्रेटर के रूप में चलने से रोकेगी जो Windows पर रूट उपयोगकर्ता के निकटतम समकक्ष है
* `securityContext.runAsUser` -[`runAsUserName`](/docs/tasks/configure-pod-container/configure-runasusername) का उपयोग करें बजाय
* `securityContext.seLinuxOptions` -Windows पर संभव नहीं है क्योंकि SELinux Linux-विशिष्ट है
* `terminationMessagePath` -इसकी कुछ सीमाएँ हैं कि Windows एकल फ़ाइलों की मैपिंग का समर्थन नहीं करता है। NS डिफ़ॉल्ट मान `/dev/termination-log` जो काम करता है क्योंकि यह डिफ़ॉल्ट रूप से Windows पर मौजूद नहीं है।

#### पॉड विनिर्देशों के लिए फ़ील्ड संगतता {#compatibility-v1-pod}

Windows और लिनक्स के बीच पॉड विनिर्देशों के काम करने के तरीके के बीच निम्न सूची दस्तावेज़ अंतर:

* `hostIPC` और `hostpid` - Windows पर होस्ट नेमस्पेस साझा करना संभव नहीं है
* `hostnetwork` - होस्ट नेटवर्क को साझा करने के लिए कोई Windows OS समर्थन नहीं है
* `dnsPolicy` - पॉड `dnsPolicy` को `ClusterFirstWithHostNet` पर सेट करना है Windows पर समर्थित नहीं है क्योंकि होस्ट नेटवर्किंग प्रदान नहीं की गई है। पॉड्स हमेशा एक कंटेनर नेटवर्क के साथ चलाएं।
* `podSecurityContext` (नीचे देखें)
* `shareProcessNamespace` - यह एक बीटा सुविधा है, और यह Linux नेमस्पेस पर निर्भर करती है जो Windows पर लागू नहीं हैं। Windows प्रक्रिया नामस्थान साझा नहीं कर सकता या कंटेनर की रूट फाइल सिस्टम। केवल नेटवर्क साझा किया जा सकता है।
* `terminationGracePeriodSeconds` - यह Windows पर डॉकर में पूरी तरह से लागू नहीं है, [गिटहब मुद्दा] (https://github.com/moby/moby/issues/25982) देखें। आज व्यवहार यह है कि ENTRYPOINT प्रक्रिया CTRL_SHUTDOWN_EVENT भेजी जाती है, तब Windows डिफ़ॉल्ट रूप से 5 सेकंड प्रतीक्षा करता है, और अंत में बंद हो जाता है सामान्य Windows शटडाउन व्यवहार का उपयोग करने वाली सभी प्रक्रियाएं। 5 दूसरा डिफ़ॉल्ट वास्तव में Windows रजिस्ट्री में है [कंटेनर के अंदर](https://github.com/moby/moby/issues/25982#issuecomment-42644183), इसलिए जब कंटेनर बनाया जाता है तो इसे ओवरराइड किया जा सकता है।
* `volumeDevice` - यह एक बीटा सुविधा है, और इसे Windows पर लागू नहीं किया गया है। Windows कच्चे ब्लॉक डिवाइस को पॉड्स में संलग्न नहीं कर सकता है।
* `volumes`
  * यदि आप 'emptyDir' वॉल्यूम को परिभाषित करते हैं, तो आप इसके वॉल्यूम स्रोत को 'memory' पर सेट नहीं कर सकते हैं।
* आप वॉल्यूम माउंट के लिए `mountPropagation` को सक्षम नहीं कर सकते क्योंकि यह Windows पर समर्थित नहीं है।


#### पॉड सुरक्षा प्रसंग के लिए फ़ील्ड संगतता {#compatibility-v1-pod-spec-containers-securitycontext}

कोई भी पॉड [`securityContext`](/docs/reference/kubernetes-api/workload-resources/pod-v1/#security-context) फ़ील्ड Windows पर काम नहीं करती है।

### नोड समस्या डिटेक्टर

नोड समस्या डिटेक्टर (देखें [नोड स्वास्थ्य की निगरानी करें](/docs/reference/kubernetes-api/workload-resources/pod-v1/#security-context)) Windows के साथ संगत नहीं है।


### कंटेनर रोकें

कुबेरनेट्स पॉड में, पहले एक बुनियादी ढांचा या "ठहराव" कंटेनर बनाया जाता है कंटेनर होस्ट करने के लिए। Linux में, cgroups और नेमस्पेस जो एक पॉड बनाते हैं अपने निरंतर अस्तित्व को बनाए रखने के लिए एक प्रक्रिया की आवश्यकता है; ठहराव प्रक्रिया प्रदान करता है यह। कंटेनर जो एक ही पॉड से संबंधित हैं, जिसमें बुनियादी ढांचा और कार्यकर्ता शामिल हैं कंटेनर, एक साझा नेटवर्क समापन बिंदु (समान IPv4 और / या IPv6 पता, समान नेटवर्क पोर्ट स्पेस)। कुबेरनेट्स वर्कर कंटेनरों को अनुमति देने के लिए पॉज़ कंटेनरों का उपयोग करता है किसी भी नेटवर्किंग कॉन्फ़िगरेशन को खोए बिना क्रैश या पुनरारंभ करना।

Kubernetes एक बहु-आर्किटेक्चर छवि रखता है जिसमें Windows के लिए समर्थन शामिल है। Kubernetes v1.22 के लिए अनुशंसित विराम छवि `k8s.gcr.io/pause:3.5` है। [स्रोत कोड](https://github.com/kubernetes/kubernetes/tree/master/build/pause) गिटहब पर उपलब्ध है।

Microsoft Linux और Windows के साथ एक अलग बहु-वास्तुकला छवि रखता है amd64 समर्थन, जिसे आप `mcr.microsoft.com/oss/kubernetes/pause:3.5` के रूप में पा सकते हैं। यह इमेज उसी स्रोत से बनाई गई है जैसे कुबेरनेट्स ने इमेज  को बनाए रखा लेकिन सभी Windows बायनेरिज़ [प्रामाणिक कोड हस्ताक्षरित](https://docs.microsoft.com/en-us/windows-hardware/drivers/install/authenticode) Microsoft द्वारा हैं। अगर आप एक उत्पादन या उत्पादन जैसे वातावरण में तैनात करना चाहते है जिसको हस्ताक्षर की हुए बिनारिएस की ज़रूरत होती है तो कुबेरनेटेस प्रोजेक्ट माइक्रोसॉफ्ट अनुरक्षित इमेज का उपयोग करने करने की अनुशंसा करता है।

### कंटेनर रनटाइम {#container-runtime}

आपको एक {{< glossary_tooltip text="कंटेनर रनटाइम" term_id="container-runtime">}} को स्थापित करने की आवश्यकता है क्लस्टर में प्रत्येक नोड में ताकि पॉड वहां चल सकें।

निम्नलिखित कंटेनर रनटाइम Windows के साथ काम करते हैं:

{{% thirdparty-content %}}

#### cri-कन्टैनर्ड

{{< feature-state for_k8s_version="v1.20" state="stable" >}}

आप {{< glossary_tooltip term_id="containerd" text="ContainerD" >}} 1.4.0+ का उपयोग कर सकते हैं Windows चलाने वाले कुबेरनेट्स नोड्स के लिए कंटेनर रनटाइम के रूप में।

जानें कि कैसे [Windows नोड पर कंटेनरडी इंस्टॉल करें](/docs/setup/production-environment/container-runtimes/#install-containerd).

{{< note >}}
एक [ज्ञात सीमा](/docs/tasks/configure-pod-container/configure-gmsa/#gmsa-limitations) है Windows नेटवर्क शेयरों तक पहुंचने के लिए कंटेनरड के साथ जीएमएसए का उपयोग करते समय, जिसके लिए एक की आवश्यकता होती है
कर्नेल पैच।
{{< /note >}}

#### डोकर EE

{{< feature-state for_k8s_version="v1.14" state="stable" >}}

[डॉकर ईई](https://docs.mirantis.com/containers/v3.0/dockeree-products/dee-intro.html)-basic 19.03+ सभी Windows सर्वर संस्करणों के लिए कंटेनर रनटाइम के रूप में उपलब्ध है। यह लीगेसी डॉकशिम एडॉप्टर के साथ काम करता है।

अधिक जानकारी के लिए [Install Docker](https://docs.microsoft.com/en-us/virtualization/windowscontainers/deploy-containers/deploy-containers-on-server#install-docker) देखें।

## Windows OS संस्करण संगतता {#windows-os-version-support}

Windows नोड्स पर, सख्त संगतता नियम लागू होते हैं जहां होस्ट OS संस्करण होना चाहिए कंटेनर आधार छवि OS संस्करण से मेल खाता है। एक कंटेनर के साथ केवल Windows कंटेनर Windows सर्वर 2019 का ऑपरेटिंग सिस्टम पूरी तरह से समर्थित है।

कुबेरनेटेस v1.22 के लिए, Windows नोड्स (और पॉड्स) के लिए ऑपरेटिंग सिस्टम संगतता इस प्रकार है:

Windows सर्वर LTSC रिलीज
: Windows सर्वर 2019

Windows सर्वर SAC रिलीज
: Windows सर्वर संस्करण 2004, Windows सर्वर संस्करण 20H2

Kubernetes [संस्करण-तिरछा नीति](/docs/setup/release/version-skew-policy/) भी लागू होता 

## Windows नोड्स के लिए सुरक्षा {#security}

Windows पर, सीक्रेट्स के डेटा को नोड के लोकल भंडारण (लिनक्स पर tmpfs / इन-मेमोरी फाइल सिस्टम के उपयोग की तुलना में) पर स्पष्ट टेक्स्ट में लिखा जाता है।

1. सीक्रेट्स की फाइल लोकेशन को सुरक्षित करने के लिए फाइल ACLs का इस्तेमाल करें।
1. [BitLocker](https://docs.microsoft.com/en-us/windows/security/information-protection/bitlocker/bitlocker-how-to-deploy-on-windows-server) का उपयोग करके वॉल्यूम-स्तर एन्क्रिप्शन लागू करें

[RunAsUsername](/docs/tasks/configure-pod-container/configure-runasusername) Windows पॉड्स या कंटेनर्स के कंटेनर की प्रक्रियाओं को नोड डिफ़ॉल्ट उपयोगकर्ता के रूप में निष्पादित किया जा सकता है। यह मोटे तौर पर [RunAsUser](/docs/concepts/policy/pod-security-policy/#users-and-groups) के बराबर है।

Linux-विशिष्ट पॉड सुरक्षा प्रसंग विशेषाधिकार जैसे SELinux, AppArmor, Seccomp, या क्षमताएं (POSIX क्षमताएं), और अन्य समर्थित नहीं हैं।

Windows पर विशेषाधिकार प्राप्त कंटेनर [समर्थित नहीं](#compatibility-v1-pod-spec-containers-securitycontext) हैं।

## सहायता प्राप्त करना और समस्या निवारण {#troubleshooting}

कुबेरनेट्स क्लस्टर के समस्या निवारण के लिए आपकी मदद का मुख्य स्रोत शुरू होना चाहिए [समस्या निवारण] (/docs/tasks/debug-application-cluster/troubleshooting/) पृष्ठ के साथ।

कुछ अतिरिक्त, Windows-विशिष्ट समस्या निवारण सहायता शामिल है इस खंड में। लॉग समस्या निवारण का एक महत्वपूर्ण तत्व हैं कुबेरनेट्स में मुद्दे। जब भी आप चाहें, उन्हें शामिल करना सुनिश्चित करें अन्य योगदानकर्ताओं से समस्या निवारण सहायता। SIG Windows [लॉग इकट्ठा करने में योगदान गाइड](https://github.com/kubernetes/community/blob/master/sig-windows/CONTRIBUTING.md#gathering-logs) निर्देशों का पालन करे।

### नोड-स्तरीय समस्या निवारण {#troubleshooting-node}

1. मुझे कैसे पता चलेगा कि `start.ps1` सफलतापूर्वक पूरा हुआ?

    आपको क्यूबलेट, क्यूब-प्रॉक्सी और (यदि आपने फलालैन को अपने नेटवर्किंग के रूप में चुना है) देखना चाहिए समाधान) फ़्लैनल्ड होस्ट-एजेंट प्रक्रियाएं आपके नोड पर चल रही लॉग के साथ चल रही हैं अलग पावरशेल विंडो में प्रदर्शित किया जा रहा है। इसके अलावा, आपका Windows नोड को आपके Kubernetes क्लस्टर में "रेडी" के रूप में सूचीबद्ध किया जाना चाहिए।
    
1. क्या मैं कुबेरनेट्स नोड प्रक्रियाओं को पृष्ठभूमि में सेवाओं के रूप में चलाने के लिए कॉन्फ़िगर कर सकता हूं?

    क्यूबलेट और क्यूब-प्रॉक्सी पहले से ही मूल Windows सेवाओं के रूप में चलाने के लिए कॉन्फ़िगर किए गए हैं,की स्थिति में स्वचालित रूप से सेवाओं को फिर से शुरू करके लचीलापन प्रदान करना विफलता (उदाहरण के लिए एक प्रक्रिया दुर्घटना)। इन्हें कॉन्फ़िगर करने के लिए आपके पास दो विकल्प हैं सेवाओं के रूप में नोड घटक।
    
    1. देशी Windows सेवाओं के रूप में

         आप क्यूबलेट और क्यूब-प्रॉक्सी को `sc.exe` का उपयोग करके देशी Windows सेवाओं के रूप में चला सकते हैं।
         
         ```powershell
             # क्यूबलेट और क्यूब-प्रॉक्सी के लिए दो अलग-अलग कमांड बनाएं
             sc.exe create <component_name> binPath= "<path_to_binary> --service <other_args>"
             
             # कृपया ध्यान दें कि यदि तर्कों में रिक्त स्थान हैं, तो उन्हें बच जाना चाहिए।
             sc.exe create kubelet binPath= "C:\kubelet.exe --service --hostname-override 'minion' <other_args>"
             
             #सेवा शुरू करें
             Start-Service kubelet
             Start-Service kube-proxy
             
             #सेवा बंद करो
             Stop-Service kubelet (-Force)
             Stop-Service kube-proxy (-Force)
             
             # सेवा की स्थिति पूछें
             Get-Service kubelet
             Get-Service kube-proxy
          ```
    1. `nssm.exe` . का उपयोग करना

        आप हमेशा वैकल्पिक सेवा प्रबंधकों का भी उपयोग कर सकते हैं जैसे [nssm.exe](https://nssm.cc/) इन प्रक्रियाओं को चलाने के लिए (फ़्लेनल्ड,क्यूबलेट और क्यूब-प्रॉक्सी) आपके लिए पृष्ठभूमि में। आप इसका इस्तेमाल कर सकते हैं [नमूना स्क्रिप्ट](https://github.com/Microsoft/SDN/tree/master/Kubernetes/flannel/register-svc.ps1),क्यूबलेट, क्यूब-प्रॉक्सी, और flanneld.exe को चलाने के लिए पंजीकृत करने के लिए nssm.exe का लाभ उठाना पृष्ठभूमि में Windows सेवाओं के रूप में।
        
        ```powershell
       register-svc.ps1 -NetworkMode <Network mode> -ManagementIP <Windows Node IP> -ClusterCIDR <Cluster subnet> -KubeDnsServiceIP <Kube-dns Service IP> -LogDir <Directory to place logs>

       # NetworkMode      = The network mode l2bridge (flannel host-gw, also the default value) or overlay (flannel vxlan) chosen as a network solution
       # ManagementIP     = The IP address assigned to the Windows node. You can use ipconfig to find this
       # ClusterCIDR      = The cluster subnet range. (Default value 10.244.0.0/16)
       # KubeDnsServiceIP = The Kubernetes DNS service IP (Default value 10.96.0.10)
       # LogDir           = The directory where kubelet and kube-proxy logs are redirected into their respective output files (Default value C:\k)
       ```
       
       प्रारंभिक समस्या निवारण के लिए, आप [nssm.exe](https://nssm.cc/) में निम्न फ़्लैग का उपयोग आउटपुट फ़ाइल पर stdout और stderr को पुनर्निर्देशित करने के लिए कर सकते हैं:
       
        ```powershell
       nssm set <Service Name> AppStdout C:\k\mysvc.log
       nssm set <Service Name> AppStderr C:\k\mysvc.log
       ```
       
       अतिरिक्त विवरण के लिए, [NSSM - नॉन-सकिंग सर्विस मैनेजर] (https://nssm.cc/usage) देखें।
       
1. माई पॉड्स "कंटेनर क्रिएटिंग" पर अटके हुए हैं या बार-बार रीस्टार्ट हो रहे हैं
    
    जांचें कि आपकी विराम छवि आपके OS संस्करण के साथ संगत है। NS [निर्देश](https://docs.microsoft.com/en-us/virtualization/windowscontainers/kubernetes/deploying-resources) मान लें कि OS और कंटेनर दोनों ही संस्करण 1803 हैं। यदि आपके पास बाद में है Windows का संस्करण, जैसे इनसाइडर बिल्ड, आपको छवियों को समायोजित करने की आवश्यकता है इसलिए। अधिक विवरण के लिए [पॉज़ कंटेनर] (#pause-container) देखें।
    
### नेटवर्क समस्या निवारण {#troubleshooting-network}

1. मेरे Windows पॉड्स में नेटवर्क कनेक्टिविटी नहीं है

    यदि आप वर्चुअल मशीन का उपयोग कर रहे हैं, तो सुनिश्चित करें कि मैक स्पूफिंग सभी VM नेटवर्क एडेप्टर पर **सक्षम** है।

2. मेरे Windows पॉड बाहरी संसाधनों को पिंग नहीं कर सकते हैं

    Windows पॉड्स में ICMP प्रोटोकॉल के लिए प्रोग्राम किए गए आउटबाउंड नियम नहीं हैं। हालाँकि, TCP/UDP समर्थित है। क्लस्टर के बाहर संसाधनों के लिए कनेक्टिविटी प्रदर्शित करने का प्रयास करते समय, `ping <IP>` को संबंधित `curl <IP>` कमांड के साथ बदलें।
    
    यदि आप अभी भी समस्याओं का सामना कर रहे हैं, तो सबसे अधिक संभावना है कि आपका नेटवर्क कॉन्फ़िगरेशन [cni.conf](https://github.com/Microsoft/SDN/blob/master/Kubernetes/flannel/l2bridge/cni/config/cni.conf) कुछ अतिरिक्त ध्यान देने योग्य है। आप इस स्थिर फ़ाइल को कभी भी संपादित कर सकते हैं। कॉन्फ़िगरेशन अद्यतन किसी भी नए Kubernetes संसाधनों पर लागू होगा।
             
    Kubernetes नेटवर्किंग आवश्यकताओं में से एक (देखें [कुबेरनेट्स मॉडल](/docs/concepts/cluster-administration/networking/)) है क्लस्टर संचार के बिना होने के लिए आंतरिक रूप से NAT। इस आवश्यकता का सम्मान करने के लिए, एक है [अपवाद सूची](https://github.com/Microsoft/SDN/blob/master/Kubernetes/flannel/l2bridge/cni/config/cni.conf#L20) उन सभी संचारों के लिए जहां आप नहीं चाहते कि आउटबाउंड NAT हो। तथापि,इसका मतलब यह भी है कि आपको उस बाहरी आईपी को बाहर करना होगा जिसे आप क्वेरी करने का प्रयास कर रहे हैं `ExceptionList` से। तभी आपके Windows से आने वाला ट्रैफिक होगा पॉड्स को बाहरी दुनिया से प्रतिक्रिया प्राप्त करने के लिए सही ढंग से SNAT'ed किया जाना चाहिए। इसमें संबंध में, आपकी `ExceptionList` `cni.conf` में इस प्रकार दिखनी चाहिए:
    
    ```conf
   "ExceptionList": [
                   "10.244.0.0/16",  # Cluster subnet
                   "10.96.0.0/12",   # Service subnet
                   "10.127.130.0/24" # Management (host) subnet
               ]
   ```

3. मेरा Windows नोड `नोडपोर्ट` प्रकार की सेवाओं तक नहीं पहुंच सकता है

    नोड से स्थानीय नोडपोर्ट पहुंच स्वयं विफल हो जाती है। यह एक ज्ञात सीमा है। NodePort एक्सेस अन्य नोड्स या बाहरी क्लाइंट से काम करता है।
    
4. कंटेनर के vNICs और HNS एंडपॉइंट हटाए जा रहे हैं

    यह समस्या तब हो सकती है जब `होस्टनाम-ओवरराइड` पैरामीटर को पास नहीं किया जाता है [क्यूब-प्रॉक्सी] (/ डॉक्स/संदर्भ/कमांड-लाइन-टूल्स-रेफरेंस/क्यूब-प्रॉक्सी/)। हल उपयोगकर्ताओं को होस्टनाम को क्यूब-प्रॉक्सी में निम्नानुसार पास करना होगा:
    
    ```powershell
   C:\k\kube-proxy.exe --hostname-override=$(hostname)
   ```
   
5. फलालैन के साथ, क्लस्टर में फिर से शामिल होने के बाद मेरे नोड्स में समस्याएं आ रही हैं

    जब भी पहले से हटाए गए नोड को क्लस्टर में फिर से जोड़ा जाता है, तो flannelD नोड को एक नया पॉड सबनेट असाइन करने का प्रयास करता है। उपयोगकर्ता पुराने पॉड को हटा दें निम्न पथों में सबनेट कॉन्फ़िगरेशन फ़ाइलें:
    
    ```powershell
   Remove-Item C:\k\SourceVip.json
   Remove-Item C:\k\SourceVipRequest.json
   ```
    
6. `Start.ps1` को लॉन्च करने के बाद, फ़्लैनेल्ड "वेटिंग फॉर द नेटवर्क टू क्रिएटेड" में फंस गया है

    इस [मुद्दे](https://github.com/coreos/flannel/issues/1066) की कई रिपोर्टें हैं; सबसे अधिक संभावना है कि यह एक समय का मुद्दा है जब फलालैन नेटवर्क का प्रबंधन आईपी सेट किया जाता है। एक समाधान यह है कि `start.ps1` को फिर से लॉन्च किया जाए या इसे मैन्युअल रूप से इस प्रकार फिर से लॉन्च किया जाए:
    
    ```powershell
   [Environment]::SetEnvironmentVariable("NODE_NAME", "<Windows_Worker_Hostname>")
   C:\flannel\flanneld.exe --kubeconfig-file=c:\k\config --iface=<Windows_Worker_Node_IP> --ip-masq=1 --kube-subnet-mgr=1
   ```
   
7. मेरे Windows पॉड्स से `/run/flannel/subnet.env` गायब होने के कारण लॉन्च नहीं हो सकते 

    यह इंगित करता है कि फ्लैनेल सही ढंग से लॉन्च नहीं हुआ। आप या तो कोशिश कर सकते हैं `flanneld.exe` को पुनः आरंभ करने के लिए या आप फ़ाइलों को मैन्युअल रूप से कॉपी कर सकते हैं कुबेरनेट्स मास्टर पर `/run/flannel/subnet.env` से `C:\run\flannel\subnet.env` Windows वर्कर नोड पर और `FLANNEL_SUBNET` पंक्ति को भिन्न में संशोधित करें संख्या। उदाहरण के लिए, यदि नोड सबनेट 10.244.4.1/24 वांछित है:
    
    ```env
   FLANNEL_NETWORK=10.244.0.0/16
   FLANNEL_SUBNET=10.244.4.1/24
   FLANNEL_MTU=1500
   FLANNEL_IPMASQ=true
   ```
   
8. मेरा Windows नोड सेवा IP का उपयोग करके मेरी सेवाओं तक नहीं पहुंच सकता है

    यह Windows पर नेटवर्किंग स्टैक की एक ज्ञात सीमा है। हालाँकि, Windows पॉड्स सर्विस आईपी तक पहुंच सकते हैं।
    
9. क्यूबलेट शुरू करते समय कोई नेटवर्क एडेप्टर नहीं मिला

    कुबेरनेट्स नेटवर्किंग के काम करने के लिए Windows नेटवर्किंग स्टैक को एक वर्चुअल एडेप्टर की आवश्यकता होती है। यदि निम्न कमांड कोई परिणाम नहीं देता है (व्यवस्थापक शेल में), वर्चुअल नेटवर्क निर्माण - क्यूबलेट के काम करने के लिए एक आवश्यक शर्त - विफल हो गया है:
    
   ```powershell
   Get-HnsNetwork | ? Name -ieq "cbr0"
   Get-NetAdapter | ? Name -Like "vEthernet (Ethernet*"
   ```
   
    अक्सर यह start.ps1 स्क्रिप्ट के [इंटरफ़ेसनाम](https://github.com/microsoft/SDN/blob/master/Kubernetes/flannel/start.ps1#L7) पैरामीटर को संशोधित करने के लिए उपयुक्त होता है, ऐसे मामलों में जहां होस्ट के नेटवर्क एडेप्टर "ईथरनेट" नहीं है। अन्यथा, वर्चुअल नेटवर्क निर्माण के दौरान त्रुटियां हैं या नहीं यह देखने के लिए `start-kubelet.ps1` स्क्रिप्ट के आउटपुट से परामर्श करें।
    
10. DNS रिज़ॉल्यूशन ठीक से काम नहीं कर रहा है

    इस [अनुभाग](#dns-limitations) में Windows के लिए DNS सीमाओं की जाँच करें।

11. `kubectl port-forward` विफल हो जाता है "पोर्ट अग्रेषण करने में असमर्थ: wincat नहीं मिला"

    यह कुबेरनेट्स 1.15 में पॉज़ इंफ्रास्ट्रक्चर कंटेनर `mcr.microsoft.com/oss/kubernetes/pause:1.4.1` में `wincat.exe` को शामिल करके लागू किया गया था। कुबेरनेट्स के समर्थित संस्करण का उपयोग करना सुनिश्चित करें।
    अगर आप अपना खुद का पॉज़ इंफ्रास्ट्रक्चर कंटेनर बनाना चाहते हैं तो [wincat](https://github.com/kubernetes/kubernetes/tree/master/build/pause/windows/wincat) को शामिल करना सुनिश्चित करें।
    
12. मेरा कुबेरनेट्स इंस्टॉलेशन विफल हो रहा है क्योंकि मेरा Windows सर्वर नोड प्रॉक्सी के पीछे है

    यदि आप किसी प्रॉक्सी के पीछे हैं, तो निम्न PowerShell परिवेश चर परिभाषित किए जाने चाहिए:
    
      ```PowerShell
   [Environment]::SetEnvironmentVariable("HTTP_PROXY", "http://proxy.example.com:80/", [EnvironmentVariableTarget]::Machine)
   [Environment]::SetEnvironmentVariable("HTTPS_PROXY", "http://proxy.example.com:443/", [EnvironmentVariableTarget]::Machine)
   ```
   
### आगे की जांच पड़ताल

यदि इन चरणों से आपकी समस्या का समाधान नहीं होता है, तो आप निम्न के माध्यम से Kubernetes में Windows नोड्स पर Windows कंटेनर चलाने में सहायता प्राप्त कर सकते हैं:

* स्टैक ओवरफ्लो [Windows सर्वर कंटेनर] (https://stackoverflow.com/questions/tagged/windows-server-container) विषय
* Kubernetes आधिकारिक फोरम [discuss.kubernetes.io](https://discuss.kubernetes.io/)
* कुबेरनेट्स स्लैक [#SIG-Windows चैनल](https://kubernetes.slack.com/messages/sig-windows)

### रिपोर्टिंग समस्याएं और सुविधा अनुरोध

यदि आपके पास कुछ ऐसा है जो बग जैसा दिखता है, या आप एक सुविधा अनुरोध करना चाहते हैं, तो कृपया [GitHub समस्या ट्रैकिंग सिस्टम](https://github.com/kubernetes/kubernetes/issues) का उपयोग करें। आप [GitHub](https://github.com/kubernetes/kubernetes/issues/new/choose) पर मुद्दों को खोल सकते हैं और उन्हें SIG-Windows को असाइन कर सकते हैं। यदि पहले इसकी रिपोर्ट की गई थी तो आपको पहले मुद्दों की सूची खोजनी चाहिए और इस मुद्दे पर अपने अनुभव के साथ टिप्पणी करनी चाहिए और अतिरिक्त लॉग जोड़ना चाहिए। टिकट बनाने से पहले कुछ प्रारंभिक समर्थन और समस्या निवारण विचार प्राप्त करने के लिए SIG-Windows स्लैक भी एक अच्छा तरीका है।

यदि कोई बग फाइल कर रहा है, तो कृपया समस्या को पुन: उत्पन्न करने के तरीके के बारे में विस्तृत जानकारी शामिल करें, जैसे:

* Kubernetes संस्करण: `kubectl version` से आउटपुट
* पर्यावरण विवरण: क्लाउड प्रदाता, ओएस डिस्ट्रो, नेटवर्किंग पसंद और कॉन्फ़िगरेशन, और डॉकर संस्करण 
* समस्या को पुन: उत्पन्न करने के लिए विस्तृत कदम
* [प्रासंगिक लॉग](https://github.com/kubernetes/community/blob/master/sig-windows/CONTRIBUTING.md#gathering-logs)

यदि आप इस मुद्दे पर `/sig windows` के साथ टिप्पणी करके समस्या को **sig/windows** के रूप में टैग करते हैं तो यह समस्या को SIG Windows सदस्य के ध्यान में लाने में मदद करता है

## {{% heading "whatsnext" %}}

### परिनियोजन उपकरण

Kubeadm टूल आपको Kubernetes क्लस्टर को तैनात करने में मदद करता है, क्लस्टर को प्रबंधित करने के लिए कंट्रोल प्लेन प्रदान करता है, और आपके वर्कलोड को चलाने के लिए नोड्स प्रदान करता है। [Windows नोड्स जोड़ना](/docs/tasks/administer-cluster/kubeadm/adding-windows-nodes/) बताता है कि kubeadm का उपयोग करके अपने क्लस्टर में Windows नोड्स को कैसे तैनात किया जाए।
kubeadm का उपयोग करके अपने क्लस्टर में Windows नोड्स को तैनात करने का तरीका बताता है।

कुबेरनेट्स [क्लस्टर एपीआई](https://cluster-api.sigs.k8s.io/) प्रोजेक्ट Windows नोड्स की तैनाती को स्वचालित करने के साधन भी प्रदान करता है।

### Windows वितरण चैनल

Windows वितरण चैनलों की विस्तृत व्याख्या के लिए [Microsoft दस्तावेज़ीकरण](https://docs.microsoft.com/en-us/windows-server/get-started-19/serviceing-channels-19) देखें।

विभिन्न Windows सर्वर सर्विसिंग चैनलों पर जानकारी उनके समर्थन मॉडल सहित यहां पाया जा सकता है [Windows सर्वर सर्विसिंग चैनल](https://docs.microsoft.com/en-us/windows-server/get-started/servicing-channels-comparison)।
