---
title: Windows containers in Kubernetes
content_type: concept
weight: 65
---

<!-- overview -->

Windows एप्लिकेशन कई संगठनों में चलने वाली सेवाओं और अनुप्रयोगों के एक बड़े हिस्से का गठन करते हैं। [Windows कंटेनर](https://aka.ms/windowscontainers) प्रक्रियाओं और पैकेज निर्भरता को समाहित करने का एक तरीका प्रदान करते हैं, जिससे DevOps प्रथाओं का उपयोग करना और Windows अनुप्रयोगों के लिए क्लाउड नेटिव पैटर्न का पालन करना आसान हो जाता है। 

Windows-आधारित अनुप्रयोगों और Linux-आधारित अनुप्रयोगों में निवेश वाले संगठनों को अपने कार्यभार को प्रबंधित करने के लिए अलग ऑर्केस्ट्रेटर की तलाश करने की आवश्यकता नहीं है, जिससे ऑपरेटिंग सिस्टम की परवाह किए बिना, उनके परिनियोजन में परिचालन क्षमता में वृद्धि होती है।

<!-- body -->

## कुबेरनेट्स में Windows नोड्स

कुबेरनेट्स में Windows कंटेनरों के ऑर्केस्ट्रेशन को सक्षम करने के लिए, अपने मौजूदा Linux क्लस्टर में Windows नोड्स शामिल करें। कुबेरनेट्स पर {{< glossary_tooltip text="पॉड्स" term_id="pod" >}} में Windows कंटेनरों को शेड्यूल करना Linux-आधारित कंटेनरों को शेड्यूल करने के समान है।

Windows कंटेनर चलाने के लिए, आपके कुबेरनेट्स क्लस्टर में कई ऑपरेटिंग सिस्टम शामिल होने चाहिए। 
जबकि आप केवल Linux पर {{< glossary_tooltip text="कंट्रोल प्लेन" term_id="control-plane" >}} चला सकते हैं, आप अपने वर्कलोड की जरूरतों के आधार पर Windows या Linux चलाने वाले वर्कर नोड्स को तैनात कर सकते हैं।

Windows {{< glossary_tooltip text="नोड्स" term_id="node" >}} [समर्थित](#windows-os-version-support) हैं बशर्ते कि ऑपरेटिंग सिस्टम Windows Server 2019 हो।

यह दस्तावेज़ *Windows कंटेनर* शब्द का उपयोग प्रोसेस आइसोलेशन वाले Windows कंटेनर के लिए करता है। कुबेरनेट्स [हाइपर-वी](https://docs.microsoft.com/en-us/virtualization/windowscontainers/manage-containers/hyperv-container) आइसोलेशन के साथ Windows कंटेनर चलाने का समर्थन नहीं करता है

## संसाधन प्रबंधन

Linux नोड्स पर, {{< glossary_tooltip text="cgroups" term_id="cgroup" >}} को संसाधन नियंत्रण के लिए पॉड सीमा के रूप में उपयोग किया जाता है। नेटवर्क, प्रक्रिया और फ़ाइल सिस्टम अलगाव के लिए उस सीमा के भीतर कंटेनर बनाए जाते हैं। Linux cgroup APIs का उपयोग CPU, I/O, और मेमोरी उपयोग के आँकड़े एकत्र करने के लिए किया जा सकता है।

इसके विपरीत, Windows एक कंटेनर में सभी प्रक्रियाओं को शामिल करने और होस्ट से तार्किक अलगाव प्रदान करने के लिए सिस्टम नेमस्पेस फ़िल्टर के साथ प्रति कंटेनर _जॉब ऑब्जेक्ट_ का उपयोग करता है।
(_जॉब ऑब्जेक्ट्स_ एक Windows प्रक्रिया अलगाव तंत्र हैं और कुबेरनेट्स जिसे {{< glossary_tooltip term_id="जॉब" text="Job" >}} कहते हैं, उससे भिन्न हैं)।

नेमस्पेस फ़िल्टरिंग के बिना Windows कंटेनर चलाने का कोई तरीका नहीं है। इसका मतलब यह है कि होस्ट के संदर्भ में सिस्टम विशेषाधिकारों का दावा नहीं किया जा सकता है, और इस प्रकार विशेषाधिकार प्राप्त कंटेनर Windows पर उपलब्ध नहीं हैं।
कंटेनर होस्ट से एक पहचान ग्रहण नहीं कर सकते क्योंकि सुरक्षा खाता प्रबंधक (एसएएम) अलग है। 

#### मेमोरी रिजर्वेशन {#resource-management-memory}

Windows में आउट-ऑफ-मेमोरी प्रोसेस किलर नहीं है जैसा कि Linux में है। Windows हमेशा सभी उपयोगकर्ता-मोड मेमोरी आवंटन को वर्चुअल मानता है, और पेजफाइल अनिवार्य हैं (Linux पर, क्यूबलेट डिफ़ॉल्ट रूप से स्वैप स्पेस सक्षम के साथ शुरू नहीं होगा)।

Windows नोड्स कंटेनरों में चल रही प्रक्रियाओं के लिए स्मृति को कम नहीं करते हैं। शुद्ध प्रभाव यह है कि Windows मेमोरी की स्थिति को उसी तरह से समाप्त नहीं करेगा जिस तरह से Linux करता है, और मेमोरी से बाहर (ओओएम) समाप्ति के अधीन होने के बजाय पेज को डिस्क पर संसाधित करता है। यदि मेमोरी का अधिक प्रावधान किया गया है और सभी भौतिक मेमोरी समाप्त हो गई है, तो पेजिंग प्रदर्शन को धीमा कर सकता है।

आप क्यूबलेट पैरामीटर `--kubelet-reserve` और/या `--system-reserve` का उपयोग करके वर्कलोड के लिए मेमोरी उपयोग पर सीमाएं लगा सकते हैं; ये नोड (कंटेनरों के बाहर) पर मेमोरी उपयोग के लिए खाते हैं, और [NodeAllocatable](/docs/tasks/administer-cluster/reserve-compute-resources.md#node-allocatable) को कम करते हैं।
जैसे ही आप वर्कलोड परिनियोजित करते हैं, कंटेनरों पर संसाधन सीमाएँ निर्धारित करें। यह `NodeAllocatable` से भी घटाता है और शेड्यूलर को नोड भर जाने के बाद अधिक पॉड जोड़ने से रोकता है।

{{< note >}}
जब आप Windows कंटेनर के लिए मेमोरी रिसोर्स लिमिट सेट करते हैं, तो आपको या तो एक लिमिट सेट करनी चाहिए और मेमोरी रिक्वेस्ट को अनिर्दिष्ट छोड़ देना चाहिए, या रिक्वेस्ट को लिमिट के बराबर सेट करना चाहिए।
{{< /note >}}

Windows पर, अति-प्रावधान से बचने के लिए अच्छा अभ्यास यह है कि क्यूबलेट को Windows, कुबेरनेट्स और कंटेनर रनटाइम ओवरहेड्स के लिए खाते में कम से कम 2GiB की सिस्टम आरक्षित मेमोरी के साथ कॉन्फ़िगर किया जाए।

#### CPU आरक्षण {#resource-management-cpu}

ऑपरेटिंग सिस्टम, कंटेनर रनटाइम और कुबेरनेट्स होस्ट प्रक्रियाओं जैसे क्यूबलेट द्वारा CPU उपयोग के लिए खाते के लिए, आप कुल CPU का एक प्रतिशत आरक्षित कर सकते हैं (और चाहिए भी)। आपको इस CPU आरक्षण को नोड पर उपलब्ध CPU कोर की संख्या को ध्यान में रखते हुए निर्धारित करना चाहिए। आरक्षित करने के लिए CPU प्रतिशत पर निर्णय लेने के लिए, प्रत्येक नोड के लिए अधिकतम पॉड घनत्व की पहचान करें और वहां चल रही सिस्टम सेवाओं के CPU उपयोग की निगरानी करें, फिर एक ऐसा मान चुनें जो आपके कार्यभार की जरूरतों को पूरा करता हो।

आप नोड पर (कंटेनरों के बाहर) CPU उपयोग के लिए क्यूबलेट पैरामीटर `--kubelet-reserve` और/या `--system-reserve` का उपयोग करके वर्कलोड के लिए CPU उपयोग पर सीमा लगा सकते हैं।
यह `NodeAllocatable` को कम करता है। पॉड प्लेसमेंट का निर्धारण करते समय क्लस्टर-वाइड शेड्यूलर इस आरक्षण को ध्यान में रखता है।

Windows पर, क्यूबलेट क्यूबलेट प्रक्रिया की प्राथमिकता निर्धारित करने के लिए कमांड-लाइन ध्वज का समर्थन करता है: `--windows-priorityclass`। यह ध्वज क्यूबलेट प्रक्रिया को Windows होस्ट पर चलने वाली अन्य प्रक्रियाओं की तुलना में अधिक CPU समय स्लाइस प्राप्त करने की अनुमति देता है। स्वीकार्य मानों और उनके अर्थ के बारे में अधिक जानकारी [Windows प्रायोरिटी क्लासेस](https://docs.microsoft.com/en-us/windows/win32/procthread/scheduling-priorities#priority-class) पर उपलब्ध है। यह सुनिश्चित करने के लिए कि रनिंग पॉड्स CPU चक्रों के क्यूबलेट को भूखा न रखें, इस फ्लैग को `ABOVE_NORMAL_PRIORITY_CLASS` या इससे ऊपर पर सेट करें।

## संगतता और सीमाएं {#limitations}

कुछ नोड सुविधाएँ केवल तभी उपलब्ध होती हैं जब आप एक विशिष्ट [कंटेनर रनटाइम](#container-runtime) का उपयोग करते हैं; अन्य Windows नोड्स पर उपलब्ध नहीं हैं, जिनमें शामिल हैं:

* HugePages: Windows कंटेनरों के लिए समर्थित नहीं है
* विशेषाधिकार प्राप्त कंटेनर: Windows कंटेनरों के लिए समर्थित नहीं है
* TerminationGracePeriod: कंटेनरडी की आवश्यकता है

साझा नेमस्पेस की सभी सुविधाएं समर्थित नहीं हैं। अधिक जानकारी के लिए [API संगतता](#api) देखें।

कुबेरनेट्स के खिलाफ परीक्षण किए गए Windows संस्करणों के विवरण के लिए [Windows ओएस संस्करण संगतता](#windows-os-version-support) देखें।

API और कुबेक्टल के नजरिए से, Windows कंटेनर Linux-आधारित कंटेनरों की तरह ही व्यवहार करते हैं। हालाँकि, प्रमुख कार्यक्षमता में कुछ उल्लेखनीय अंतर हैं जिन्हें इस खंड में उल्लिखित किया गया है।

### Linux के साथ तुलना {#compatibility-linux-similarities}

कुंजी कुबेरनेट्स तत्व Windows में उसी तरह काम करते हैं जैसे वे Linux में करते हैं। 
//FIXME:
यह खंड कई प्रमुख वर्कलोड एनबलर्स को संदर्भित करता है और वे Windows पर कैसे मैप करते हैं।

* [पॉड्स](/docs/concepts/workloads/pods/)
  
  पॉड कुबेरनेट्स का मूल निर्माण खंड है - कुबेरनेट्स ऑब्जेक्ट मॉडल में सबसे छोटी और सरल इकाई जिसे आप बनाते हैं या तैनात करते हैं। आप एक ही पॉड में Windows और Linux कंटेनर को तैनात नहीं कर सकते हैं। पॉड में सभी कंटेनर एक ही नोड पर निर्धारित होते हैं जहां प्रत्येक नोड एक विशिष्ट प्लेटफॉर्म और आर्किटेक्चर का प्रतिनिधित्व करता है। निम्नलिखित पॉड क्षमताएं, गुण और घटनाएं Windows कंटेनरों के साथ समर्थित हैं:

  * प्रोसेस आइसोलेशन और वॉल्यूम साझाकरण के साथ प्रति पॉड एकल या एकाधिक कंटेनर
  * पॉड `status` फ़ील्ड
  * तत्परता और जीवंतता जांच
  * पोस्टस्टार्ट और प्रीस्टॉप कंटेनर जीवनचक्र घटनाएँ
  * कॉन्फिग मैप, सीक्रेट्स: एनवायरनमेंट वेरिएबल या वॉल्यूम के रूप में
  * `emptyDir` वॉल्यूम
  * नामित पाइप होस्ट माउंट
  * संसाधन सीमा
* [वर्कलोड संसाधन](/docs/concepts/workloads/controllers/) including:
  * रेप्लिकेसेट 
  * डिप्लॉयमेंट 
  * स्टटेफूलसेट 
  * डेमनसेट
  * जॉब 
  * क्रोंजोब  
  * रेप्लिकेशनकंट्रोलर 
* {{< glossary_tooltip text="सेवाएं" term_id="service" >}}
  अधिक जानकारी के लिए [लोड बैलेंसिंग](#load-balancing-and-services) और सेवाएं देखें।

कुबेरनेट्स पर Windows वर्कलोड को प्रबंधित करने के लिए पॉड्स, वर्कलोड संसाधन और सेवाएं महत्वपूर्ण तत्व हैं। हालांकि, अपने दम पर वे एक डायनामिक क्लाउड नेटिव वातावरण में Windows वर्कलोड के उचित जीवनचक्र प्रबंधन को सक्षम करने के लिए पर्याप्त नहीं हैं। कुबेरनेट्स इनका भी समर्थन करता है:

* `kubectl exec`
* पॉड और कंटेनर मेट्रिक्स
* {{< glossary_tooltip text="क्षैतिज पॉड ऑटोस्केलिंग" term_id="horizontal-pod-autoscaler" >}}
* {{< glossary_tooltip text="संसाधन कोटा" term_id="resource-quota" >}}
* शेड्यूलर प्रीएंपशन


### Windows नोड्स पर नेटवर्किंग {#compatibility-networking}

Windows कंटेनरों के लिए नेटवर्किंग [CNI प्लगइन्स](/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/) के माध्यम से उजागर होती है।
Windows कंटेनर नेटवर्किंग के संबंध में वर्चुअल मशीनों के समान कार्य करते हैं। प्रत्येक कंटेनर में एक वर्चुअल नेटवर्क एडेप्टर (vNIC) होता है जो एक Hyper-V वर्चुअल स्विच (vSwitch) से जुड़ा होता है। होस्ट नेटवर्किंग सर्विस (HNS) और होस्ट कंप्यूट सर्विस (HCS) कंटेनर बनाने और कंटेनर vNIC को नेटवर्क से जोड़ने के लिए एक साथ काम करते हैं। HCS कंटेनरों के प्रबंधन के लिए जिम्मेदार है जबकि HNS नेटवर्किंग संसाधनों के प्रबंधन के लिए जिम्मेदार है जैसे:

* वर्चुअल नेटवर्क (vSwitches के निर्माण सहित)
* समापन बिंदु / vNIC
* नेमस्पेस
* नीतियों में पैकेट एनकैप्सुलेशन, लोड-बैलेंसिंग नियम, ACL और NAT नियम शामिल हैं।

#### कंटेनर नेटवर्किंग {#networking}

Windows HNS और vSwitch नेमस्पेसिंग को लागू करते हैं और पॉड या कंटेनर के लिए आवश्यकतानुसार वर्चुअल NIC बना सकते हैं। हालाँकि, कई कॉन्फ़िगरेशन जैसे कि DNS, रूट और मेट्रिक्स Windows रजिस्ट्री डेटाबेस में संग्रहीत होते हैं, न कि `/ etc` के अंदर फाइलों के रूप में, जो कि Linux उन कॉन्फ़िगरेशन को कैसे संग्रहीत करता है। कंटेनर के लिए Windows रजिस्ट्री होस्ट की रजिस्ट्री से अलग है, इसलिए होस्ट से कंटेनर में `/etc/resolv.conf` मैप करने जैसी अवधारणाएं Linux पर समान प्रभाव नहीं डालती हैं। इन्हें उस कंटेनर के संदर्भ में चलाए जा रहे Windows API का उपयोग करके कॉन्फ़िगर किया जाना चाहिए। इसलिए CNI कार्यान्वयन को पॉड या कंटेनर में नेटवर्क विवरण पास करने के लिए फ़ाइल मैपिंग पर निर्भर रहने के बजाय HNS को कॉल करने की आवश्यकता है।

निम्न नेटवर्किंग कार्यक्षमता Windows नोड्स पर समर्थित नहीं है:

* होस्ट नेटवर्किंग मोड
* नोड से ही स्थानीय नोडपोर्ट एक्सेस (अन्य नोड्स या बाहरी क्लाइंट के लिए काम करता है)
* एक ही सेवा के लिए 64 से अधिक बैकएंड पॉड (या अद्वितीय गंतव्य पते)
* ओवरले नेटवर्क से जुड़े Windows पॉड्स के बीच IPv6 संचार
* Non-DSR मोड में लोकल ट्रैफिक नीति
* Azure-CNI प्लगइन का उपयोग करके या `win-overlay`, `win-bridge` के माध्यम से ICMP प्रोटोकॉल का उपयोग करके आउटबाउंड संचार।\
  विशेष रूप से, Windows डेटा प्लेन ([VFP](https://www.microsoft.com/en-us/research/project/azure-virtual-filtering-platform/)) ICMP पैकेट ट्रांसपोजिशन का समर्थन नहीं करता है, और इसका मतलब है :
   * एक ही नेटवर्क के भीतर गंतव्यों के लिए निर्देशित ICMP पैकेट (जैसे पिंग के माध्यम से पॉड से पॉड संचार) अपेक्षित और बिना किसी सीमा के काम करते हैं;
   * TCP/UDP पैकेट अपेक्षित और बिना किसी सीमा के कार्य करते हैं;
   * एक रिमोट नेटवर्क से गुजरने के लिए निर्देशित ICMP पैकेट (उदाहरण के लिए पिंग के माध्यम से बाहरी इंटरनेट संचार के लिए पॉड) को स्थानांतरित नहीं किया जा सकता है और इस प्रकार उनके स्रोत पर वापस नहीं भेजा जाएगा;
   * चूंकि TCP/UDP पैकेट अभी भी स्थानांतरित किए जा सकते हैं, आप बाहरी दुनिया के साथ कनेक्टिविटी में कुछ डिबगिंग अंतर्दृष्टि प्राप्त करने के लिए `ping <destination>` को `curl <destination>` से प्रतिस्थापित कर सकते हैं। 

क्यूब-प्रॉक्सी में ओवरले नेटवर्किंग सपोर्ट एक बीटा फीचर है। इसके अलावा, इसे [KB4482887](https://support.microsoft.com/en-us/help/4482887/windows-10-update-kb4482887) को Windows Server 2019 पर इंस्टॉल करना होगा।

#### नेटवर्क मोड

Windows पांच अलग-अलग नेटवर्किंग ड्राइवर/मोड का समर्थन करता है: l2bridge, L2tunnel, ओवरले (बीटा), ट्रांसपेरेंट और NAT. Windows और Linux वर्कर नोड्स के साथ एक विषम क्लस्टर में, आपको एक नेटवर्किंग समाधान का चयन करने की आवश्यकता है जो Windows और Linux दोनों पर संगत हो। निम्नलिखित आउट-ऑफ-ट्री प्लगइन्स Windows पर समर्थित हैं, प्रत्येक सीएनआई का उपयोग कब करना है, इस पर सिफारिशों के साथ:

| नेटवर्क ड्राइवर | विवरण | कंटेनर पैकेट संशोधन | नेटवर्क प्लगइन्स | नेटवर्क प्लगइन अभिलक्षण |
| --------- | ---- | -------------- | ---------- | ---------------- |
| l2bridge | कंटेनर बाहरी vSwitch से जुड़े होते हैं। कंटेनर अंडरले नेटवर्क से जुड़े होते हैं, हालांकि भौतिक नेटवर्क को कंटेनर MAC सीखने की आवश्यकता नहीं होती है क्योंकि वे प्रवेश/निकास पर फिर से लिखे जाते हैं। | MAC को होस्ट करने के लिए MAC को फिर से लिखा जाता है, HNS OutboundNAT नीति का उपयोग करके IP को होस्ट करने के लिए IP को फिर से लिखा जा सकता है। | [win-bridge](https://github.com/containernetworking/plugins/tree/master/plugins/main/windows/win-bridge), [Azure-CNI](https://github.com/Azure/azure-container-networking/blob/master/docs/cni.md), फलालैन होस्ट-गेटवे win-bridge का उपयोग करता है | win-bridge l2bridge नेटवर्क मोड का उपयोग करता है, कंटेनरों को मेजबानों के बुनियाद से जोड़ता है, सर्वश्रेष्ठ प्रदर्शन की पेशकश करता है। इंटर-नोड कनेक्टिविटी के लिए यूजर-डिफ़ाइंड रूट्स (UDR) की आवश्यकता होती है। |
| L2Tunnel | यह l2bridge का एक विशेष मामला है, लेकिन केवल Azure पर उपयोग किया जाता है। सभी पैकेट वर्चुअलाइजेशन होस्ट को भेजे जाते हैं जहां एसडीएन नीति लागू होती है। | मैक फिर से लिखा, अंडरले नेटवर्क पर दिखाई देने वाला आईपी | [Azure-CNI](https://github.com/Azure/azure-container-networking/blob/master/docs/cni.md) | Azure-CNI, Azure vNET के साथ कंटेनरों के एकीकरण की अनुमति देता है, और उन्हें क्षमताओं के सेट का लाभ उठाने की अनुमति देता है जो [Azure वर्चुअल नेटवर्क प्रदान करता है](https://azure.microsoft.com/en-us/services/virtual-network/)। उदाहरण के लिए, Azure सेवाओं से सुरक्षित रूप से कनेक्ट करें या Azure NSG का उपयोग करें। [कुछ उदाहरणों के लिए Azure-cni] देखें (https://docs.microsoft.com/en-us/azure/aks/concepts-network#azure-cni-advanced-networking) | 
| ओवरले (कुबेरनेट्स में Windows के लिए ओवरले नेटवर्किंग *अल्फा* चरण में है) | कंटेनरों को एक बाहरी vSwitch से जुड़ा एक vNIC दिया जाता है। प्रत्येक ओवरले नेटवर्क को अपना स्वयं का IP सबनेट मिलता है, जिसे एक कस्टम IP प्रीफिक्स द्वारा परिभाषित किया जाता है। ओवरले नेटवर्क ड्राइवर VXLAN एनकैप्सुलेशन का उपयोग करता है। | बाहरी हैडर के द्वारा एन्काप्सुलेट किया गया। | [win-overlay](https://github.com/containernetworking/plugins/tree/master/plugins/main/windows/win-overlay), फलालैन VXLAN (win-overlay का उपयोग करता है) | win-overlay का उपयोग तब किया जाना चाहिए जब वर्चुअल कंटेनर नेटवर्क को मेजबानों के बुनियाद (जैसे सुरक्षा कारणों से) से अलग किया जाना चाहिए। यदि आप अपने डेटासेंटर में IP पर प्रतिबंधित हैं तो IP को विभिन्न ओवरले नेटवर्क (जिसमें अलग-अलग VNID टैग हैं) के लिए पुन: उपयोग करने की अनुमति देता है। इस विकल्प के लिए Windows सर्वर 2019 पर [KB4489899](https://support.microsoft.com/help/4489899) की आवश्यकता है।
| पारदर्शी ([ovn-कुबेरनेट्स](https://github.com/openvswitch/ovn-kubernetes) के लिए विशेष उपयोग के मामले) |एक बाहरी vSwitch की आवश्यकता है। कंटेनर एक बाहरी vSwitch से जुड़े होते हैं जो तार्किक नेटवर्क (लॉजिकल स्विच और राउटर) के माध्यम से इंट्रा-पॉड संचार को सक्षम बनाता है। | पैकेट को या तो  [GENEVE](https://datatracker.ietf.org/doc/draft-gross-geneve/) या [STT](https://datatracker.ietf.org/doc/draft-davie-stt/) टनलिंग के माध्यम से पॉड्स तक पहुँचने के लिए इनकैप्सुलेट किया जाता है जो एक ही होस्ट पर नहीं होते हैं। <br/> पैकेट को ovn नेटवर्क नियंत्रक द्वारा आपूर्ति की गई टनल मेटाडेटा जानकारी के माध्यम से अग्रेषित या गिराया जाता है। <br/> NAT उत्तर-दक्षिण संचार के लिए किया जाता है। | [ovn-kubernetes](https://github.com/openvswitch/ovn-kubernetes) | [ansible के माध्यम से परिनियोजित करें](https://github.com/openvswitch/ovn-kubernetes/tree/master/contrib)। वितरित ACL को Kubernetes नीतियों के माध्यम से लागू किया जा सकता है। IPAM समर्थन। क्यूब-प्रॉक्सी के बिना लोड-बैलेंसिंग हासिल की जा सकती है। नेटिंग iptables/netsh का उपयोग किए बिना किया जाता है। |
| NAT (*कुबेरनेट्स में उपयोग नहीं किया गया*) | कंटेनरों को एक आंतरिक vSwitch से जुड़ा एक vNIC दिया जाता है। DNS/DHCP [WinNAT](https://blogs.technet.microsoft.com/virtualization/2016/05/25/windows-nat-winnat-capabilities-and-limitations/) नामक एक आंतरिक घटक का उपयोग करके प्रदान किया जाता है  | MAC/IP को होस्ट करने के लिए MAC और IP को फिर से लिखा जाता है। | [nat](https://github.com/Microsoft/windows-container-networking/tree/master/plugins/nat) | पूर्णता के लिए यहां शामिल है |

जैसा कि ऊपर बताया गया है, [फलालैन](https://github.com/coreos/flannel) CNI [मेटा प्लगइन](https://github.com/containernetworking/plugins/tree/master/plugins/meta/flannel) Windows पर [VXLAN नेटवर्क बैकएंड](https://github.com/coreos/flannel/blob/master/Documentation/backends.md#vxlan) (**alpha support** ; delegates to win-overlay) (**अल्फा सपोर्ट**; win-overlay के प्रतिनिधि) और [होस्ट-गेटवे नेटवर्क बैकएंड](https://github.com/coreos/flannel/blob/master/Documentation/backends.md#host-gw) (stable support; delegates to win-bridge) (स्थिर समर्थन; win-bridge के प्रतिनिधि) के माध्यम से भी [समर्थित](https://github.com/containernetworking/plugins/tree/master/plugins/meta/flannel#windows-support-experimental) है। 

यह प्लगइन एक संदर्भ CNI प्लगइन्स (win-overlay, win-bridge) को सौंपने का समर्थन करता है, स्वचालित नोड सबनेट लीज असाइनमेंट और HNS नेटवर्क निर्माण के लिए Windows (FlannelD) पर फलालैन डेमॉन के संयोजन के साथ काम करने के लिए। यह प्लगइन अपनी स्वयं की कॉन्फ़िगरेशन फ़ाइल (cni.conf) में पढ़ता है, और इसे FlannelD द्वारा उत्पन्न subnet.env फ़ाइल से पर्यावरण चर के साथ जोड़ता है। यह तब नेटवर्क प्लंबिंग के लिए संदर्भ CNI प्लगइन्स में से एक को सौंपता है, और IPAM प्लगइन (उदाहरण के लिए: `host-local`) को नोड-असाइन सबनेट युक्त सही कॉन्फ़िगरेशन भेजता है।

नोड, पॉड और सर्विस ऑब्जेक्ट के लिए, निम्न नेटवर्क प्रवाह TCP/UDP ट्रैफ़िक के लिए समर्थित हैं:

* पॉड → पॉड (IP)
* पॉड → पॉड (नाम)
* पॉड → सर्विस (क्लस्टर IP)
* पॉड → सर्विस (पीक्यूडीएन, लेकिन केवल अगर "." नहीं हैं)
* पॉड → सर्विस (FQDN)
* पॉड → बाहरी (IP)
* पॉड → बाहरी (DNS)
* नोड → पॉड
* पॉड → नोड

#### सीएनआई प्लगइन सीमाएं

* Windows संदर्भ नेटवर्क प्लगइन्स win-bridge और win-overlay [CNI स्पेक] (https://github.com/containernetworking/cni/blob/master/SPEC.md) v0.4.0 को लागू नहीं करते हैं, एक लापता `CHECK` कार्यान्वयन के कारण।
* फलालैन VXLAN CNI प्लगइन की Windows पर निम्नलिखित सीमाएँ हैं:

1. डिजाइन द्वारा नोड-पॉड कनेक्टिविटी संभव नहीं है। यह केवल Flannel v0.12.0 (या उच्चतर) वाले स्थानीय पॉड्स के लिए संभव है।
2. फलालैन VNI 4096 और UDP पोर्ट 4789 का उपयोग करने के लिए प्रतिबंधित है। इन मापदंडों पर अधिक विवरण के लिए आधिकारिक [फलालैन VXLAN](https://github.com/coreos/flannel/blob/master/Documentation/backends.md#vxlan) बैकएंड डॉक्स देखें।

#### IP एड्रेस मैनेजमेंट (IPAM) {#ipam}

निम्न IPAM विकल्प Windows पर समर्थित हैं:

* [host-local](https://github.com/containernetworking/plugins/tree/master/plugins/ipam/host-local)
* HNS IPAM (इनबॉक्स प्लेटफॉर्म IPAM, यह एक फॉलबैक है जब कोई IPAM सेट नहीं होता है)
* [azure-vnet-ipam](https://github.com/Azure/azure-container-networking/blob/master/docs/ipam.md) (केवल Azure-CNI के लिए)

#### लोड संतुलन और सेवाएं

कुबेरनेट्स {{< glossary_tooltip text="सेवा" term_id="service" >}} एक अमूर्त है जो पॉड्स के लॉजिकल सेट और नेटवर्क पर उन्हें एक्सेस करने के साधन को परिभाषित करती है।
एक क्लस्टर में जिसमें Windows नोड्स शामिल हैं, आप निम्न प्रकार की सेवा का उपयोग कर सकते हैं:

  * `NodePort`
  * `ClusterIP`
  * `LoadBalancer`
  * `ExternalName`

Windows कंटेनर नेटवर्किंग कुछ महत्वपूर्ण तरीकों से Linux नेटवर्किंग से अलग है।
[Windows कंटेनर नेटवर्किंग के लिए Microsoft दस्तावेज़](https://docs.microsoft.com/en-us/virtualization/windowscontainers/container-networking/architecture) अतिरिक्त विवरण और पृष्ठभूमि प्रदान करता है।

On Windows, you can use the following settings to configure Services and load
balancing behavior:

{{< table caption="Windows सेवा सेटिंग्स" >}}
| फ़ीचर | विवरण | समर्थित कुबेरनेट्स संस्करण | समर्थित Windows ओएस बिल्ड | कैसे सक्षम करें |
| --- | ---- | ------------------ | --------------------- | ---------- |
| सत्र आत्मीयता | यह सुनिश्चित करता है कि किसी विशेष क्लाइंट से कनेक्शन हर बार उसी पॉड को पास किया जाता है। | v1.20+ | [Windows सर्वर वीनेक्स्ट इनसाइडर प्रीव्यू बिल्ड 19551](https://blogs.windows.com/windowsexperience/2020/01/28/announcing-windows-server-vnext-insider-preview-build-19551/) (या उच्चतर) | `service.spec.sessionAffinity` को "ClientIP" पर सेट करें |
| डायरेक्ट सर्वर रिटर्न (DSR) | लोड संतुलन मोड जहां IP एड्रेस ठीक हो जाता है और LBNAT सीधे कंटेनर vSwitch पोर्ट पर होता है; सेवा यातायात स्रोत आईपी के साथ आता है जो मूल पॉड आईपी के रूप में सेट होता है। | v1.20+ | Windows सर्वर 2019 | क्यूब-प्रॉक्सी में निम्न फ़्लैग सेट करें: `--feature-gates="WinDSR=true" --enable-dsr=true` |
| संरक्षित-गंतव्य | सेवा ट्रैफ़िक के DNAT को छोड़ देता है, जिससे लक्ष्य सेवा के वर्चुअल IP को बैकएंड पॉड तक पहुँचने वाले पैकेट में संरक्षित किया जाता है। नोड-नोड अग्रेषण को भी अक्षम करता है। | v1.20+ | Windows सर्वर, संस्करण 1903 (या उच्चतर) | सेवा एनोटेशन में `"preserve-destination": "true"` सेट करें और क्यूब-प्रॉक्सी में DSR सक्षम करें। |
| IPv4/IPv6 डुअल-स्टैक नेटवर्किंग | नेटिव IPv4-to-IPv4 IPv6-to-IPv6 संचार के साथ समानांतर में एक क्लस्टर से, से, और भीतर | v1.19+ | Windows सर्वर, संस्करण 2019 | देखें [IPv4/IPv6 डुअल-स्टैक](#ipv4ipv6-dual-stack) |
| क्लाइंट आईपी संरक्षण | सुनिश्चित करता है कि आने वाले प्रवेश यातायात का स्रोत आईपी संरक्षित हो जाता है। नोड-नोड अग्रेषण को भी अक्षम करता है। | v1.20+ | Windows सर्वर, संस्करण 2019 | `service.spec.externalTrafficPolicy` को "Local" पर सेट करें और क्यूब-प्रॉक्सी में DSR सक्षम करें |
{{< /table >}}

##### सत्र आत्मीयता

`service.spec.sessionAffinityConfig.clientIP.timeoutSeconds` का उपयोग करके Windows सेवाओं के लिए अधिकतम सत्र स्टिकी समय सेट करना समर्थित नहीं है।

#### DNS {#dns-limitations}

* ClusterFirstWithHostNet DNS के लिए समर्थित नहीं है। Windows उन सभी नामों को एक FQDN के रूप में मानता है जो `.` के साथ हैं और FQDN रिज़ॉल्यूशन को छोड़ देते हैं।
* Linux पर, आपके पास DNS प्रत्यय सूची है, जिसका उपयोग PQDN को हल करने का प्रयास करते समय किया जाता है। Windows पर, आपके पास केवल 1 DNS प्रत्यय हो सकता है, जो कि उस पॉड के नामस्थान से जुड़ा DNS प्रत्यय है (उदाहरण के लिए mydns.svc.cluster.local)। Windows FQDNs और सेवाओं या नामों को केवल उस प्रत्यय के साथ हल कर सकता है। उदाहरण के लिए, डिफ़ॉल्ट नाम स्थान में उत्पन्न पॉड में DNS प्रत्यय होगा **default.svc.cluster.local**। Windows पॉड के अंदर, आप **kubernetes.default.svc.cluster.local** और **kubernetes** दोनों को हल कर सकते हैं, लेकिन इनके बीच के नहीं नहीं, जैसे **kubernetes.default** या **kubernetes.default.svc**।
* Windows पर, कई DNS रिज़ॉल्वर हैं जिनका उपयोग किया जा सकता है। चूंकि ये थोड़े अलग व्यवहार के साथ आते हैं, नाम क्वेरी समाधान के लिए `Resolve-DNSName` उपयोगिता का उपयोग करने की अनुशंसा की जाती है।

#### IPv6 नेटवर्किंग

Windows पर Kubernetes सिंगल-स्टैक "IPv6-only" नेटवर्किंग का समर्थन नहीं करता है। हालांकि, एकल परिवार सेवाओं के साथ पॉड्स और नोड्स के लिए डुअल-स्टैक IPv4/IPv6 नेटवर्किंग समर्थित है।

आप `IPv6DualStack` [फीचर गेट] (/ डॉक्स/रेफरेंस/कमांड-लाइन-टूल्स-रेफरेंस/फीचर-गेट्स/) का उपयोग करके `l2bridge` नेटवर्क के लिए IPv4/IPv6 डुअल-स्टैक नेटवर्किंग को सक्षम कर सकते हैं।
अधिक जानकारी के लिए देखें [इनेबल IPv4/IPv6 डुअल स्टैक](/docs/concepts/services-networking/dual-stack#enable-ipv4ipv6-dual-stack)।

{{< note >}}
Windows पर ओवरले (VXLAN) नेटवर्क डुअल-स्टैक नेटवर्किंग का समर्थन नहीं करते हैं।
{{< /note >}}

### परसिस्टेंट स्टोरेज {#compatibility-storage}

कंटेनर परतों को माउंट करने और NTFS पर आधारित एक कॉपी फाइल सिस्टम बनाने के लिए Windows में एक स्तरित फाइल सिस्टम ड्राइवर है। कंटेनर में सभी फ़ाइल पथ केवल उस कंटेनर के संदर्भ में हल किए जाते हैं।

* डॉकर के साथ, वॉल्यूम माउंट केवल कंटेनर में एक निर्देशिका को लक्षित कर सकता है, न कि एक व्यक्तिगत फ़ाइल। यह सीमा CRI-containerD रनटाइम के साथ मौजूद नहीं है।
* वॉल्यूम माउंट फ़ाइलों या निर्देशिकाओं को होस्ट फ़ाइल सिस्टम पर वापस प्रोजेक्ट नहीं कर सकता है।
* रीड-ओन्ली के लिए फाइल सिस्टम समर्थित नहीं हैं क्योंकि Windows रजिस्ट्री और SAM डेटाबेस के लिए हमेशा लेखन पहुंच की आवश्यकता होती है। हालाँकि, रीड-ओन्ली के लिए वॉल्यूम समर्थित हैं।
* वॉल्यूम उपयोगकर्ता-मास्क और अनुमतियां उपलब्ध नहीं हैं। क्योंकि SAM को होस्ट और कंटेनर के बीच साझा नहीं किया जाता है, इसलिए उनके बीच कोई मैपिंग नहीं होती है। कंटेनर के संदर्भ में सभी अनुमतियों का समाधान किया जाता है।

परिणामस्वरूप, निम्न संग्रहण कार्यक्षमता Windows नोड्स पर समर्थित नहीं है:

* वॉल्यूम सबपाथ माउंट: केवल संपूर्ण वॉल्यूम को Windows कंटेनर में रखा जा सकता है
* सीक्रेट्स के लिए सबपाथ वॉल्यूम मॉउंटिंग
* होस्ट माउंट प्रोजेक्शन
* रीड-ओन्ली के लिए रूट फाइल सिस्टम (मैप किए गए वॉल्यूम अभी भी `readOnly` का समर्थन करते हैं)
* ब्लॉक डिवाइस मैपिंग
* मेमोरी स्टोरेज माध्यम के रूप में (उदाहरण के लिए, `emptyDir.medium` `Memory` पर सेट है)
* फ़ाइल सिस्टम सुविधाएँ जैसे uid/gid; प्रति-उपयोगकर्ता Linux फ़ाइल सिस्टम अनुमतियाँ
* DefaultMode (UID/GID निर्भरता के कारण)
* NFS आधारित स्टोरेज/वॉल्यूम समर्थन
* माउंटेड वॉल्यूम का विस्तार करना (resizefs)

कुबेरनेट्स {{< glossary_tooltip text="वॉल्यूम" term_id="volume" >}} जटिल अनुप्रयोगों को सक्षम करता है, डेटा पर्सिस्टेंस और पॉड वॉल्यूम साझाकरण आवश्यकताओं के साथ, कुबेरनेट्स पर तैनात किया जा सकता है। एक विशिष्ट स्टोरेज बैक-एंड या प्रोटोकॉल से जुड़े लगातार वॉल्यूम के प्रबंधन में वॉल्यूम का प्रावधान / डी-प्रावधान / आकार बदलना, कुबेरनेट्स नोड से वॉल्यूम को जोड़ना / अलग करना और वॉल्यूम को अलग-अलग कंटेनरों में / से माउंट करना / हटाना जैसी क्रियाएं शामिल हैं। एक पॉड में जिसे डेटा बनाए रखने की आवश्यकता होती है।

एक विशिष्ट स्टोरेज बैक-एंड या प्रोटोकॉल के लिए इन वॉल्यूम प्रबंधन क्रियाओं को लागू करने वाला कोड कुबेरनेट्स वॉल्यूम [प्लगइन] (/ डॉक्स/कॉन्सेप्ट्स/स्टोरेज/वॉल्यूम/# टाइप्स-ऑफ-वॉल्यूम) के रूप में शिप किया जाता है।
कुबेरनेट्स वॉल्यूम प्लगइन्स के निम्नलिखित व्यापक वर्ग Windows पर समर्थित हैं: 

##### इन-ट्री वॉल्यूम प्लगइन्स

कोर कुबेरनेट्स कॉड बेस के हिस्से के रूप में इन-ट्री वॉल्यूम प्लगइन्स से जुड़ा कोड। इन-ट्री वॉल्यूम प्लग इन के परिनियोजन के लिए अतिरिक्त स्क्रिप्ट की स्थापना या अलग कंटेनरीकृत प्लगइन घटकों की तैनाती की आवश्यकता नहीं होती है। ये प्लगइन्स स्टोरेज बैकएंड में वॉल्यूम के प्रोविजनिंग / डी-प्रोविजनिंग और आकार का आकार बदल सकते हैं, एक कुबेरनेट्स नोड से / वॉल्यूम को अटैच / डिटैच कर सकते हैं और एक पॉड में अलग-अलग कंटेनरों से वॉल्यूम को माउंट / डिसमाउंट कर सकते हैं। निम्नलिखित इन-ट्री प्लगइन्स Windows नोड्स पर लगातार स्टोरेज का समर्थन करते हैं:

* [`awsElasticBlockStore`](/docs/concepts/storage/volumes/#awselasticblockstore)
* [`azureDisk`](/docs/concepts/storage/volumes/#azuredisk)
* [`azureFile`](/docs/concepts/storage/volumes/#azurefile)
* [`gcePersistentDisk`](/docs/concepts/storage/volumes/#gcepersistentdisk)
* [`vsphereVolume`](/docs/concepts/storage/volumes/#vspherevolume)

#### फ्लेक्सवॉल्यूम प्लगइन्स

[FlexVolume](/docs/concepts/storage/volumes/#flexVolume) प्लगइन्स से जुड़े कोड आउट-ऑफ-ट्री स्क्रिप्ट या बायनेरिज़ के रूप में शिप होते हैं जिन्हें सीधे होस्ट पर तैनात करने की आवश्यकता होती है। फ्लेक्सवॉल्यूम प्लगइन्स कुबेरनेट्स नोड से/वॉल्यूम को जोड़ने/डिटैच करने और एक पॉड में अलग-अलग कंटेनर से वॉल्यूम को माउंट/डिसमाउंट करने का काम करता है। FlexVolume प्लगइन्स से जुड़े लगातार वॉल्यूम का प्रोविजनिंग / डी-प्रोविजनिंग एक बाहरी प्रोविजनर के माध्यम से किया जा सकता है जो आमतौर पर FlexVolume प्लगइन्स से अलग होता है। निम्न FlexVolume [प्लगइन्स](https://github.com/Microsoft/K8s-Storage-Plugins/tree/master/flexvolume/windows), होस्ट पर PowerShell स्क्रिप्ट के रूप में परिनियोजित, Windows नोड्स का समर्थन करते हैं:

* [SMB](https://github.com/microsoft/K8s-Storage-Plugins/tree/master/flexvolume/windows/plugins/microsoft.com~smb.cmd)
* [iSCSI](https://github.com/microsoft/K8s-Storage-Plugins/tree/master/flexvolume/windows/plugins/microsoft.com~iscsi.cmd)

#### CSI प्लगइन्स

{{< feature-state for_k8s_version="v1.19" state="beta" >}}

{{<glossary_tooltip text="CSI" term_id="csi" >}} प्लगइन्स से जुड़ा कोड आउट-ऑफ-ट्री स्क्रिप्ट और बायनेरिज़ के रूप में शिप होता है जो आमतौर पर कंटेनर इमेज के रूप में वितरित किए जाते हैं और डेमनसेट्स और स्टेटफुलसेट्स जैसे मानक कुबेरनेट्स कंस्ट्रक्शन का उपयोग करके तैनात किए जाते हैं। CSI प्लगइन्स कुबेरनेट्स में वॉल्यूम प्रबंधन क्रियाओं की एक विस्तृत श्रृंखला को संभालते हैं: वॉल्यूम का प्रावधान / डी-प्रोविज़निंग / आकार बदलना, वॉल्यूम को कुबेरनेट्स नोड से / से जोड़ना / अलग करना और एक पॉड में अलग-अलग कंटेनरों में / से वॉल्यूम को बढ़ाना / हटाना, बैकअप /स्नैपशॉट और क्लोनिंग का उपयोग करके लगातार डेटा की पुनर्स्थापना। CSI प्लगइन्स में आमतौर पर नोड प्लग इन (जो प्रत्येक नोड पर डेमनसेट के रूप में चलता है) और कंट्रोलर प्लगइन्स होते हैं।

CSI नोड प्लगइन्स (विशेष रूप से ब्लॉक डिवाइस या साझा फाइल-सिस्टम के रूप में उजागर होने वाले लगातार वॉल्यूम से जुड़े) को डिस्क डिवाइस की स्कैनिंग, फाइल सिस्टम की माउंटिंग आदि जैसे विभिन्न विशेषाधिकार प्राप्त संचालन करने की आवश्यकता होती है। ये ऑपरेशन प्रत्येक होस्ट ऑपरेटिंग सिस्टम के लिए भिन्न होते हैं। . Linux वर्कर नोड्स के लिए, कंटेनरीकृत CSI नोड प्लग इन को आमतौर पर विशेषाधिकार प्राप्त कंटेनरों के रूप में तैनात किया जाता है। Windows वर्कर नोड्स के लिए, कंटेनरीकृत CSI नोड प्लगइन्स के लिए विशेषाधिकार प्राप्त संचालन [CSI-प्रॉक्सी](https://github.com/kubernetes-csi/csi-proxy) का उपयोग करके समर्थित है, जो की एक समुदाय-प्रबंधित, स्टैंड-अलोन बाइनरी जिसे प्रत्येक Windows नोड पर पूर्व-स्थापित करने की आवश्यकता होती है।

अधिक विवरण के लिए, आप जिस CSI प्लगइन को परिनियोजित करना चाहते हैं उसकी परिनियोजन मार्गदर्शिका देखें।

### क्यूबलेट के लिए कमांड लाइन विकल्प {#kubelet-compatibility}

कुछ क्यूबलेट कमांड लाइन विकल्पों का व्यवहार Windows पर अलग तरह से व्यवहार करता है, जैसा कि नीचे वर्णित है:

* `--windows-priorityclass` आपको क्यूबलेट प्रक्रिया की शेड्यूलिंग प्राथमिकता निर्धारित करने देता है (देखें [CPU संसाधन प्रबंधन](#resource-management-cpu))
* `--kubelet-reserve`, `--system-reserve` , और `--eviction-hard` फ्लैग अपडेट [NodeAllocatable](/docs/tasks/admin-cluster/reserve-comput-resource/#node-allocatable)
* '--enforce-node-allocable' का उपयोग करके निष्कासन लागू नहीं किया गया है
* बेदखली के लिए `--eviction-hard` और `--एविक्शन-सॉफ्ट` का प्रयोग नहीं किया जाता है
* विंडोज नोड पर चलने वाले क्यूबलेट में मेमोरी प्रतिबंध नहीं होते हैं। `--kubelet-reserve` और `--system-reserve` क्यूबलेट या होस्ट पर चलने वाली प्रक्रियाओं पर सीमा निर्धारित नहीं करते हैं। इसका मतलब है कि क्यूबलेट या होस्ट पर एक प्रक्रिया नोड-आवंटन योग्य और अनुसूचक के बाहर स्मृति संसाधन भुखमरी का कारण बन सकती है।
* `MemoryPressure` शर्त लागू नहीं की गई है
* क्यूबलेट OOM निष्कासन कार्रवाई नहीं करता